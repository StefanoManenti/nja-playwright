globalThis.jotaiAtomCache = globalThis.jotaiAtomCache || {
  cache: /* @__PURE__ */ new Map(),
  get(name, inst) {
    if (this.cache.has(name)) {
      return this.cache.get(name);
    }
    this.cache.set(name, inst);
    return inst;
  }
};
import { atom } from "/@fs/C:/Users/aintrona/Desktop/App/react/naj/node_modules/.vite/apps/naj/deps/jotai.js?v=0189a8d1";
import { ImmediateEffect } from "/@fs/C:/Users/aintrona/Desktop/App/react/naj/libs/data-access/src/lib/effective-dates/types.ts";
import { addBusinessDays } from "/@fs/C:/Users/aintrona/Desktop/App/react/naj/libs/util/src/index.ts";
export { addBusinessDays };
export const currentDate = globalThis.jotaiAtomCache.get("C:\\Users\\aintrona\\Desktop\\App\\react\\naj\\libs\\data-access\\src\\lib\\effective-dates\\utils.ts/currentDate", atom(() => {
  return today();
}));
currentDate.debugLabel = "currentDate";
export function getEffectiveDate(effectiveDates, immediateEffect) {
  if (immediateEffect == null || immediateEffect === ImmediateEffect.NOT_SELECTED) {
    return;
  }
  return (immediateEffect ? effectiveDates.dateFastActivation : effectiveDates.dateStandardActivation) ?? void 0;
}
export function getFirstDateOfTheNextMonth(date) {
  if (date.getDate() === 1) {
    return date;
  }
  const date1 = new Date(date);
  date1.setDate(1);
  date1.setMonth(date.getMonth() + 1);
  return date1;
}
export function addSolarDays(date, increment) {
  const date1 = new Date(date);
  date1.setDate(date.getDate() + increment);
  return date1;
}
export async function addDays(date, increment, type = "solar") {
  return type === "solar" ? addSolarDays(date, increment) : addBusinessDays(date, increment);
}
export function today() {
  return /* @__PURE__ */ new Date();
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLFNBQVNBLFlBQVk7QUFDckIsU0FBU0MsdUJBQThDO0FBQ3ZELFNBQVNDLHVCQUF1QjtBQUVoQyxTQUFTQTtBQUtULGFBQUFDLGNBQUFDLFdBQUFDLGVBQUFDLElBQUEscUhBQTJCTixLQUFLLE1BQU07QUFDcEMsU0FBT08sTUFBTTtBQUNmLENBQUMsQ0FBQztBQUVGSixZQUFBSyxhQUFBO0FBTU8sZ0JBQVNDLGlCQUNkQyxnQkFDQUMsaUJBQ0E7QUFDQSxNQUNFQSxtQkFBbUIsUUFDbkJBLG9CQUFvQlYsZ0JBQWdCVyxjQUNwQztBQUNBO0FBQUEsRUFDRjtBQUNBLFVBQ0dELGtCQUNHRCxlQUFlRyxxQkFDZkgsZUFBZUksMkJBQTJCQztBQUVsRDtBQVFPLGdCQUFTQywyQkFBMkJDLE1BQVk7QUFDckQsTUFBSUEsS0FBS0MsUUFBUSxNQUFNLEdBQUc7QUFDeEIsV0FBT0Q7QUFBQUEsRUFDVDtBQUVBLFFBQU1FLFFBQVEsSUFBSUMsS0FBS0gsSUFBSTtBQUMzQkUsUUFBTUUsUUFBUSxDQUFDO0FBQ2ZGLFFBQU1HLFNBQVNMLEtBQUtNLFNBQVMsSUFBSSxDQUFDO0FBQ2xDLFNBQU9KO0FBQ1Q7QUFRTyxnQkFBU0ssYUFBYVAsTUFBWVEsV0FBbUI7QUFDMUQsUUFBTU4sUUFBUSxJQUFJQyxLQUFLSCxJQUFJO0FBQzNCRSxRQUFNRSxRQUFRSixLQUFLQyxRQUFRLElBQUlPLFNBQVM7QUFDeEMsU0FBT047QUFDVDtBQUVBLHNCQUFzQk8sUUFDcEJULE1BQ0FRLFdBQ0FFLE9BQTZCLFNBQzdCO0FBQ0EsU0FBT0EsU0FBUyxVQUNaSCxhQUFhUCxNQUFNUSxTQUFTLElBQzVCdkIsZ0JBQWdCZSxNQUFNUSxTQUFTO0FBQ3JDO0FBTU8sZ0JBQVNsQixRQUFRO0FBQ3RCLFNBQU8sb0JBQUlhLEtBQUs7QUFDbEIiLCJuYW1lcyI6WyJhdG9tIiwiSW1tZWRpYXRlRWZmZWN0IiwiYWRkQnVzaW5lc3NEYXlzIiwiY3VycmVudERhdGUiLCJnbG9iYWxUaGlzIiwiam90YWlBdG9tQ2FjaGUiLCJnZXQiLCJ0b2RheSIsImRlYnVnTGFiZWwiLCJnZXRFZmZlY3RpdmVEYXRlIiwiZWZmZWN0aXZlRGF0ZXMiLCJpbW1lZGlhdGVFZmZlY3QiLCJOT1RfU0VMRUNURUQiLCJkYXRlRmFzdEFjdGl2YXRpb24iLCJkYXRlU3RhbmRhcmRBY3RpdmF0aW9uIiwidW5kZWZpbmVkIiwiZ2V0Rmlyc3REYXRlT2ZUaGVOZXh0TW9udGgiLCJkYXRlIiwiZ2V0RGF0ZSIsImRhdGUxIiwiRGF0ZSIsInNldERhdGUiLCJzZXRNb250aCIsImdldE1vbnRoIiwiYWRkU29sYXJEYXlzIiwiaW5jcmVtZW50IiwiYWRkRGF5cyIsInR5cGUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsidXRpbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXRvbSB9IGZyb20gJ2pvdGFpJztcclxuaW1wb3J0IHsgSW1tZWRpYXRlRWZmZWN0LCBQYXJ0aWFsRWZmZWN0aXZlRGF0ZXMgfSBmcm9tICcuL3R5cGVzJztcclxuaW1wb3J0IHsgYWRkQnVzaW5lc3NEYXlzIH0gZnJvbSAnQG5hai13by91dGlsJztcclxuXHJcbmV4cG9ydCB7IGFkZEJ1c2luZXNzRGF5cyB9O1xyXG5cclxuLyoqXHJcbiAqIEF0b20gdGhhdCByZXR1cm5zIHRoZSBjdXJyZW50IGRhdGVcclxuICovXHJcbmV4cG9ydCBjb25zdCBjdXJyZW50RGF0ZSA9IGF0b20oKCkgPT4ge1xyXG4gIHJldHVybiB0b2RheSgpO1xyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBlZmZlY3RpdmUgZGF0ZSBiYXNlZCBvbiB0aGUgaW1tZWRpYXRlIGVmZmVjdCBzZWxlY3Rpb25cclxuICogQHBhcmFtIGVmZmVjdGl2ZURhdGVzIC0gT2JqZWN0IGNvbnRhaW5pbmcgZmFzdCBhbmQgc3RhbmRhcmQgYWN0aXZhdGlvbiBkYXRlc1xyXG4gKiBAcGFyYW0gaW1tZWRpYXRlRWZmZWN0IC0gU2VsZWN0ZWQgaW1tZWRpYXRlIGVmZmVjdCBvcHRpb25cclxuICogQHJldHVybnMgVGhlIGFwcHJvcHJpYXRlIGFjdGl2YXRpb24gZGF0ZSBiYXNlZCBvbiB0aGUgaW1tZWRpYXRlIGVmZmVjdCBzZWxlY3Rpb24sIG9yIHVuZGVmaW5lZCBpZiBub3Qgc2VsZWN0ZWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRFZmZlY3RpdmVEYXRlKFxyXG4gIGVmZmVjdGl2ZURhdGVzOiBQYXJ0aWFsRWZmZWN0aXZlRGF0ZXMsXHJcbiAgaW1tZWRpYXRlRWZmZWN0OiBJbW1lZGlhdGVFZmZlY3QgfCB1bmRlZmluZWRcclxuKSB7XHJcbiAgaWYgKFxyXG4gICAgaW1tZWRpYXRlRWZmZWN0ID09IG51bGwgfHxcclxuICAgIGltbWVkaWF0ZUVmZmVjdCA9PT0gSW1tZWRpYXRlRWZmZWN0Lk5PVF9TRUxFQ1RFRFxyXG4gICkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICByZXR1cm4gKFxyXG4gICAgKGltbWVkaWF0ZUVmZmVjdFxyXG4gICAgICA/IGVmZmVjdGl2ZURhdGVzLmRhdGVGYXN0QWN0aXZhdGlvblxyXG4gICAgICA6IGVmZmVjdGl2ZURhdGVzLmRhdGVTdGFuZGFyZEFjdGl2YXRpb24pID8/IHVuZGVmaW5lZFxyXG4gICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIG5leHQgbW9udGggZnJvbSB0aGUgZ2l2ZW4gZGF0ZVxyXG4gKiBAcGFyYW0gZGF0ZSAtIFNvdXJjZSBkYXRlXHJcbiAqIEByZXR1cm5zIERhdGUgb2JqZWN0IHNldCB0byBmaXJzdCBkYXkgb2YgbmV4dCBtb250aCBpZiBkYXRlIGlzIG5vdCBhbHJlYWR5IGZpcnN0IG9mIG1vbnRoLFxyXG4gKiBvdGhlcndpc2UgcmV0dXJucyBvcmlnaW5hbCBkYXRlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Rmlyc3REYXRlT2ZUaGVOZXh0TW9udGgoZGF0ZTogRGF0ZSkge1xyXG4gIGlmIChkYXRlLmdldERhdGUoKSA9PT0gMSkge1xyXG4gICAgcmV0dXJuIGRhdGU7XHJcbiAgfVxyXG5cclxuICBjb25zdCBkYXRlMSA9IG5ldyBEYXRlKGRhdGUpO1xyXG4gIGRhdGUxLnNldERhdGUoMSk7XHJcbiAgZGF0ZTEuc2V0TW9udGgoZGF0ZS5nZXRNb250aCgpICsgMSk7XHJcbiAgcmV0dXJuIGRhdGUxO1xyXG59XHJcblxyXG4vKipcclxuICogQWRkcyBzcGVjaWZpZWQgbnVtYmVyIG9mIGRheXMgdG8gYSBkYXRlXHJcbiAqIEBwYXJhbSBkYXRlIC0gU291cmNlIGRhdGVcclxuICogQHBhcmFtIGluY3JlbWVudCAtIE51bWJlciBvZiBkYXlzIHRvIGFkZFxyXG4gKiBAcmV0dXJucyBOZXcgZGF0ZSB3aXRoIGRheXMgYWRkZWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGRTb2xhckRheXMoZGF0ZTogRGF0ZSwgaW5jcmVtZW50OiBudW1iZXIpIHtcclxuICBjb25zdCBkYXRlMSA9IG5ldyBEYXRlKGRhdGUpO1xyXG4gIGRhdGUxLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyBpbmNyZW1lbnQpO1xyXG4gIHJldHVybiBkYXRlMTtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFkZERheXMoXHJcbiAgZGF0ZTogRGF0ZSxcclxuICBpbmNyZW1lbnQ6IG51bWJlcixcclxuICB0eXBlOiAnc29sYXInIHwgJ2J1c2luZXNzJyA9ICdzb2xhcidcclxuKSB7XHJcbiAgcmV0dXJuIHR5cGUgPT09ICdzb2xhcidcclxuICAgID8gYWRkU29sYXJEYXlzKGRhdGUsIGluY3JlbWVudClcclxuICAgIDogYWRkQnVzaW5lc3NEYXlzKGRhdGUsIGluY3JlbWVudCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIGN1cnJlbnQgZGF0ZSBhbmQgdGltZVxyXG4gKiBAcmV0dXJucyBDdXJyZW50IGRhdGUgYXMgRGF0ZSBvYmplY3RcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0b2RheSgpIHtcclxuICByZXR1cm4gbmV3IERhdGUoKTtcclxufVxyXG4iXSwiZmlsZSI6IkM6L1VzZXJzL2FpbnRyb25hL0Rlc2t0b3AvQXBwL3JlYWN0L25hai9saWJzL2RhdGEtYWNjZXNzL3NyYy9saWIvZWZmZWN0aXZlLWRhdGVzL3V0aWxzLnRzIn0=