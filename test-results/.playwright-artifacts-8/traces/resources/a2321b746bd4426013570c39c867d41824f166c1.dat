globalThis.jotaiAtomCache = globalThis.jotaiAtomCache || {
  cache: /* @__PURE__ */ new Map(),
  get(name, inst) {
    if (this.cache.has(name)) {
      return this.cache.get(name);
    }
    this.cache.set(name, inst);
    return inst;
  }
};
import { atom } from "/@fs/C:/Users/aintrona/Desktop/App/react/naj/node_modules/.vite/apps/naj/deps/jotai.js?v=0189a8d1";
import { atomWithSuspenseQuery } from "/@fs/C:/Users/aintrona/Desktop/App/react/naj/node_modules/.vite/apps/naj/deps/jotai-tanstack-query.js?v=0189a8d1";
import { addClearMethodToError, isErrorClearable } from "/@fs/C:/Users/aintrona/Desktop/App/react/naj/libs/util/src/index.ts";
export function atomWithRetryableQuery(getOptions) {
  const resetAtom = atom(0);
  resetAtom.debugLabel = "resetAtom";
  return atom(async (get) => {
    const reset = get(resetAtom);
    const options = await getOptions(get);
    if (!options) {
      return;
    }
    const {
      queryFn,
      queryKey
    } = options;
    const queryAtom = atomWithSuspenseQuery(() => ({
      queryKey: [...queryKey, reset],
      queryFn: async (queryKey2) => {
        try {
          return {
            value: await queryFn(queryKey2)
          };
        } catch (error) {
          return {
            error
          };
        }
      }
    }));
    const {
      data
    } = await get(queryAtom);
    if ("error" in data) {
      const error = data.error;
      if (!isErrorClearable(error)) {
        addClearMethodToError(error, resetAtom);
      }
      throw error;
    }
    return data.value;
  });
}
export function atomWithErrorReset(read) {
  const resetAtom = atom(0);
  resetAtom.debugLabel = "resetAtom";
  return atom(async (get) => {
    get(resetAtom);
    try {
      return await read(get);
    } catch (error) {
      if (!isErrorClearable(error)) {
        addClearMethodToError(error, resetAtom);
        throw error;
      }
      throw error;
    }
  });
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUVBLFNBQWVBLFlBQW9CO0FBQ25DLFNBQVNDLDZCQUE2QjtBQUV0QyxTQUFTQyx1QkFBdUJDLHdCQUF3QjtBQUVqRCxnQkFBU0MsdUJBTWRDLFlBT3NCO0FBQ3RCLFFBQU1DLFlBQVlOLEtBQUssQ0FBQztBQUV4Qk0sWUFBQUMsYUFBQTtBQUNBLFNBQU9QLEtBQUssT0FBT1EsUUFBUTtBQUN6QixVQUFNQyxRQUFRRCxJQUFJRixTQUFTO0FBQzNCLFVBQU1JLFVBQVUsTUFBTUwsV0FBV0csR0FBRztBQUNwQyxRQUFJLENBQUNFLFNBQVM7QUFDWjtBQUFBLElBQ0Y7QUFFQSxVQUFNO0FBQUEsTUFBRUM7QUFBQUEsTUFBU0M7QUFBQUEsSUFBUyxJQUFJRjtBQUM5QixVQUFNRyxZQUFZWixzQkFBc0IsT0FBTztBQUFBLE1BQzdDVyxVQUFVLENBQUMsR0FBR0EsVUFBVUgsS0FBSztBQUFBLE1BQzdCRSxTQUFTLE9BQU9DLGNBQWE7QUFDM0IsWUFBSTtBQUNGLGlCQUFPO0FBQUEsWUFBRUUsT0FBTyxNQUFNSCxRQUFRQyxTQUFRO0FBQUEsVUFBRTtBQUFBLFFBQzFDLFNBQVNHLE9BQU87QUFFZCxpQkFBTztBQUFBLFlBQUVBO0FBQUFBLFVBQU07QUFBQSxRQUNqQjtBQUFBLE1BQ0Y7QUFBQSxJQUNGLEVBQUU7QUFFRixVQUFNO0FBQUEsTUFBRUM7QUFBQUEsSUFBSyxJQUFJLE1BQU1SLElBQUlLLFNBQVM7QUFDcEMsUUFBSSxXQUFXRyxNQUFNO0FBQ25CLFlBQU1ELFFBQVFDLEtBQUtEO0FBQ25CLFVBQUksQ0FBQ1osaUJBQWlCWSxLQUFLLEdBQUc7QUFDNUJiLDhCQUFzQmEsT0FBT1QsU0FBUztBQUFBLE1BQ3hDO0FBQ0EsWUFBTVM7QUFBQUEsSUFDUjtBQUNBLFdBQU9DLEtBQUtGO0FBQUFBLEVBQ2QsQ0FBQztBQUNIO0FBTU8sZ0JBQVNHLG1CQUNkQyxNQUNrQjtBQUNsQixRQUFNWixZQUFZTixLQUFLLENBQUM7QUFBRU0sWUFBQUMsYUFBQTtBQUUxQixTQUFPUCxLQUFLLE9BQU9RLFFBQVE7QUFDekJBLFFBQUlGLFNBQVM7QUFFYixRQUFJO0FBQ0YsYUFBTyxNQUFNWSxLQUFLVixHQUFHO0FBQUEsSUFDdkIsU0FBU08sT0FBTztBQUNkLFVBQUksQ0FBQ1osaUJBQWlCWSxLQUFLLEdBQUc7QUFDNUJiLDhCQUFzQmEsT0FBT1QsU0FBUztBQUN0QyxjQUFNUztBQUFBQSxNQUNSO0FBQ0EsWUFBTUE7QUFBQUEsSUFDUjtBQUFBLEVBQ0YsQ0FBQztBQUNIIiwibmFtZXMiOlsiYXRvbSIsImF0b21XaXRoU3VzcGVuc2VRdWVyeSIsImFkZENsZWFyTWV0aG9kVG9FcnJvciIsImlzRXJyb3JDbGVhcmFibGUiLCJhdG9tV2l0aFJldHJ5YWJsZVF1ZXJ5IiwiZ2V0T3B0aW9ucyIsInJlc2V0QXRvbSIsImRlYnVnTGFiZWwiLCJnZXQiLCJyZXNldCIsIm9wdGlvbnMiLCJxdWVyeUZuIiwicXVlcnlLZXkiLCJxdWVyeUF0b20iLCJ2YWx1ZSIsImVycm9yIiwiZGF0YSIsImF0b21XaXRoRXJyb3JSZXNldCIsInJlYWQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiYXRvbVdpdGhSZXRyeWFibGVRdWVyeS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEZWZhdWx0RXJyb3IsIFF1ZXJ5RnVuY3Rpb24gfSBmcm9tICdAdGFuc3RhY2svcXVlcnktY29yZSc7XHJcbmltcG9ydCB0eXBlIHsgUXVlcnlLZXkgfSBmcm9tICdAdGFuc3RhY2svcmVhY3QtcXVlcnknO1xyXG5pbXBvcnQgeyBBdG9tLCBhdG9tLCBHZXR0ZXIgfSBmcm9tICdqb3RhaSc7XHJcbmltcG9ydCB7IGF0b21XaXRoU3VzcGVuc2VRdWVyeSB9IGZyb20gJ2pvdGFpLXRhbnN0YWNrLXF1ZXJ5JztcclxuaW1wb3J0IHR5cGUgeyBPcHRpb25hbFByb21pc2UgfSBmcm9tICcuLi9hdG9tcy90eXBlcyc7XHJcbmltcG9ydCB7IGFkZENsZWFyTWV0aG9kVG9FcnJvciwgaXNFcnJvckNsZWFyYWJsZSB9IGZyb20gJ0BuYWotd28vdXRpbCc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYXRvbVdpdGhSZXRyeWFibGVRdWVyeTxcclxuICBUUXVlcnlGbkRhdGEgPSB1bmtub3duLFxyXG4gIFRFcnJvciA9IERlZmF1bHRFcnJvcixcclxuICBURGF0YSA9IFRRdWVyeUZuRGF0YSxcclxuICBUUXVlcnlLZXkgZXh0ZW5kcyBRdWVyeUtleSA9IFF1ZXJ5S2V5XHJcbj4oXHJcbiAgZ2V0T3B0aW9uczogKGdldDogR2V0dGVyKSA9PiBPcHRpb25hbFByb21pc2U8XHJcbiAgICB8IHtcclxuICAgICAgICBxdWVyeUZuOiBRdWVyeUZ1bmN0aW9uPFRRdWVyeUZuRGF0YSwgVFF1ZXJ5S2V5LCBuZXZlcj47XHJcbiAgICAgICAgcXVlcnlLZXk6IFRRdWVyeUtleTtcclxuICAgICAgfVxyXG4gICAgfCB1bmRlZmluZWRcclxuICA+XHJcbik6IEF0b208UHJvbWlzZTxURGF0YT4+IHtcclxuICBjb25zdCByZXNldEF0b20gPSBhdG9tKDApO1xyXG5cclxuICAvLyBAdHMtZXhwZWN0LWVycm9yIHR5cGVzY3JpcHQgbWFnaWNzXHJcbiAgcmV0dXJuIGF0b20oYXN5bmMgKGdldCkgPT4ge1xyXG4gICAgY29uc3QgcmVzZXQgPSBnZXQocmVzZXRBdG9tKTtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSBhd2FpdCBnZXRPcHRpb25zKGdldCk7XHJcbiAgICBpZiAoIW9wdGlvbnMpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHsgcXVlcnlGbiwgcXVlcnlLZXkgfSA9IG9wdGlvbnM7XHJcbiAgICBjb25zdCBxdWVyeUF0b20gPSBhdG9tV2l0aFN1c3BlbnNlUXVlcnkoKCkgPT4gKHtcclxuICAgICAgcXVlcnlLZXk6IFsuLi5xdWVyeUtleSwgcmVzZXRdIGFzIHVua25vd24gYXMgVFF1ZXJ5S2V5LFxyXG4gICAgICBxdWVyeUZuOiBhc3luYyAocXVlcnlLZXkpID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGF3YWl0IHF1ZXJ5Rm4ocXVlcnlLZXkpIH07XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSB3ZSBkbyBub3QgbGlrZSB0aGUgZmFjdCB0aGF0IHRhbnN0YWNrIHF1ZXJ5IGRvZXMgbm90IGNhY2hlIGVycm9ycyAodW5saWtlIGpvdGFpKS5cclxuICAgICAgICAgIHJldHVybiB7IGVycm9yIH07XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgfSkpO1xyXG5cclxuICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgZ2V0KHF1ZXJ5QXRvbSk7XHJcbiAgICBpZiAoJ2Vycm9yJyBpbiBkYXRhKSB7XHJcbiAgICAgIGNvbnN0IGVycm9yID0gZGF0YS5lcnJvcjtcclxuICAgICAgaWYgKCFpc0Vycm9yQ2xlYXJhYmxlKGVycm9yKSkge1xyXG4gICAgICAgIGFkZENsZWFyTWV0aG9kVG9FcnJvcihlcnJvciwgcmVzZXRBdG9tKTtcclxuICAgICAgfVxyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICAgIHJldHVybiBkYXRhLnZhbHVlO1xyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogUGVybWl0cyByZXNldHRpbmcgYW4gYXRvbSB0aGF0IGNhbiB0aHJvdyBhbiBlcnJvci4gU2ltaWxhciB0byBhdG9tV2l0aFJldHJ5YWJsZVF1ZXJ5XHJcbiAqIEBwYXJhbSByZWFkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXRvbVdpdGhFcnJvclJlc2V0PFQgPSBuZXZlcj4oXHJcbiAgcmVhZDogKGdldDogR2V0dGVyKSA9PiBQcm9taXNlPFQ+XHJcbik6IEF0b208UHJvbWlzZTxUPj4ge1xyXG4gIGNvbnN0IHJlc2V0QXRvbSA9IGF0b20oMCk7XHJcblxyXG4gIHJldHVybiBhdG9tKGFzeW5jIChnZXQpID0+IHtcclxuICAgIGdldChyZXNldEF0b20pO1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiBhd2FpdCByZWFkKGdldCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBpZiAoIWlzRXJyb3JDbGVhcmFibGUoZXJyb3IpKSB7XHJcbiAgICAgICAgYWRkQ2xlYXJNZXRob2RUb0Vycm9yKGVycm9yLCByZXNldEF0b20pO1xyXG4gICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICB9XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcbiJdLCJmaWxlIjoiQzovVXNlcnMvYWludHJvbmEvRGVza3RvcC9BcHAvcmVhY3QvbmFqL2xpYnMvZGF0YS1hY2Nlc3Mvc3JjL2xpYi91dGlscy9hdG9tV2l0aFJldHJ5YWJsZVF1ZXJ5LnRzIn0=