globalThis.jotaiAtomCache = globalThis.jotaiAtomCache || {
  cache: /* @__PURE__ */ new Map(),
  get(name, inst) {
    if (this.cache.has(name)) {
      return this.cache.get(name);
    }
    this.cache.set(name, inst);
    return inst;
  }
};
import { atom, useSetAtom } from "/@fs/C:/Users/aintrona/Desktop/App/react/naj/node_modules/.vite/apps/naj/deps/jotai.js?v=0189a8d1";
import { atomWithSuspenseQuery } from "/@fs/C:/Users/aintrona/Desktop/App/react/naj/node_modules/.vite/apps/naj/deps/jotai-tanstack-query.js?v=0189a8d1";
import { loadable } from "/@fs/C:/Users/aintrona/Desktop/App/react/naj/node_modules/.vite/apps/naj/deps/jotai_utils.js?v=0189a8d1";
import __vite__cjsImport3_react from "/@fs/C:/Users/aintrona/Desktop/App/react/naj/node_modules/.vite/apps/naj/deps/react.js?v=0189a8d1"; const useEffect = __vite__cjsImport3_react["useEffect"]; const useMemo = __vite__cjsImport3_react["useMemo"]; const useRef = __vite__cjsImport3_react["useRef"];
import { fetchPanelEstimateProduction } from "/@fs/C:/Users/aintrona/Desktop/App/react/naj/libs/data-access/src/lib/api/panel-adoption/index.ts";
import { virtualPanelOffer$ } from "/@fs/C:/Users/aintrona/Desktop/App/react/naj/libs/data-access/src/lib/api/products-collection/index.ts";
import { powerSupplySelectedAtom } from "/@fs/C:/Users/aintrona/Desktop/App/react/naj/libs/data-access/src/lib/atoms/supply-selected-power.ts";
export const panelsAvailableAtom = globalThis.jotaiAtomCache.get("C:\\Users\\aintrona\\Desktop\\App\\react\\naj\\libs\\data-access\\src\\lib\\atoms\\panels-atoms.ts/panelsAvailableAtom", atom(async (get) => {
  const v = await get(virtualPanelOffer$);
  return v?.locations;
}));
panelsAvailableAtom.debugLabel = "panelsAvailableAtom";
export const panelsSelectedAtom = globalThis.jotaiAtomCache.get("C:\\Users\\aintrona\\Desktop\\App\\react\\naj\\libs\\data-access\\src\\lib\\atoms\\panels-atoms.ts/panelsSelectedAtom", atom([]));
panelsSelectedAtom.debugLabel = "panelsSelectedAtom";
const panelsDetailsAtom = (panelsSelectedAtom2) => atom(async (get) => {
  const panelsAvailable = await get(panelsAvailableAtom);
  const panelsSelected = get(panelsSelectedAtom2);
  function getLocationById(locationId) {
    return panelsAvailable?.find(({
      id
    }) => id === locationId);
  }
  function getSizeByProductId(location, productId) {
    return location?.sizes.find((size) => size.productId === productId);
  }
  return panelsSelected.map(({
    locationId,
    panelId
  }) => {
    const location = getLocationById(locationId);
    if (!location) {
      return null;
    }
    const size = getSizeByProductId(location, panelId);
    if (!size) {
      return null;
    }
    const panelsSelected2 = {
      location,
      size
    };
    return panelsSelected2;
  }).filter((x) => !!x);
});
export const panelsSelectedDetailsAtom = panelsDetailsAtom(panelsSelectedAtom);
const panelBestSizeAtom = globalThis.jotaiAtomCache.get("C:\\Users\\aintrona\\Desktop\\App\\react\\naj\\libs\\data-access\\src\\lib\\atoms\\panels-atoms.ts/panelBestSizeAtom", atom(async (get) => {
  const supply = await get(powerSupplySelectedAtom);
  const panelBestSize = supply?.panelBestSize;
  if (!panelBestSize) return;
  return get(panelBestSize);
}));
panelBestSizeAtom.debugLabel = "panelBestSizeAtom";
export const panelLocationsAtom = globalThis.jotaiAtomCache.get("C:\\Users\\aintrona\\Desktop\\App\\react\\naj\\libs\\data-access\\src\\lib\\atoms\\panels-atoms.ts/panelLocationsAtom", atom(async (get) => {
  const locations = await get(panelsAvailableAtom);
  const panelBestSize = await get(panelBestSizeAtom);
  const l = locations?.map((location) => ({
    ...location,
    suggestedPanel: getSuggestedPanel(location, panelBestSize)?.productId
  })).map((location) => [location.id, location]);
  return new Map(l);
}));
panelLocationsAtom.debugLabel = "panelLocationsAtom";
function getSuggestedPanel(location, suggestedPower) {
  if (!suggestedPower) {
    return;
  }
  const bestPower = parseFloat(suggestedPower);
  const EPSILON = 0.01;
  const index = location.sizes.map((panel, i) => ({
    power: parseFloat(panel.power),
    i
  })).filter(({
    power
  }) => power < bestPower + EPSILON).sort((a, b) => b.power - a.power)[0]?.i;
  return index != null ? location.sizes[index] : location.sizes[0];
}
export function useEstimatedProductionAtom(panels) {
  const panelsAtom = useRef(atom([]));
  const set = useSetAtom(panelsAtom.current);
  const oldPanels = useRef();
  useEffect(() => {
    if (panels) {
      const current = JSON.stringify(panels);
      if (oldPanels.current !== current) {
        oldPanels.current = current;
        set([...panels]);
      }
    }
  });
  return useMemo(() => {
    const estimatedProductionAtom = atom(async (get) => {
      const panelsDetails = await get(panelsDetailsAtom(panelsAtom.current));
      return {
        powers: panelsDetails.map(({
          size
        }) => parseFloat(size.power)),
        estimatedProductions: panelsDetails.map(({
          location
        }) => atomWithSuspenseQuery(() => ({
          retry: 0,
          queryKey: ["location", location.lat, location.lng],
          queryFn: async () => {
            const production = await fetchPanelEstimateProduction({
              lat: location.lat,
              lng: location.lng
            });
            return parseFloat(production);
          }
        })))
      };
    });
    estimatedProductionAtom.debugLabel = "estimatedProductionAtom";
    return loadable(atom(async (get) => {
      const {
        powers,
        estimatedProductions
      } = await get(estimatedProductionAtom);
      const promises = estimatedProductions.map((a) => get(a));
      const data = await Promise.all(promises);
      let sum = 0;
      for (let i = 0; i < data.length; i++) {
        sum += data[i].data * powers[i];
      }
      return sum.toFixed(0);
    }));
  }, []);
}

//# sourceMappingURL=data:application/json;base64,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UUFBUyxNQUNsRHhCLHNCQUFzQixPQUFPO0FBQUEsVUFDM0JnRSxPQUFPO0FBQUEsVUFDUEMsVUFBVSxDQUFDLFlBQVl6QyxTQUFTMEMsS0FBSzFDLFNBQVMyQyxHQUFHO0FBQUEsVUFDakRDLFNBQVMsWUFBWTtBQUNuQixrQkFBTUMsYUFBYSxNQUFNaEUsNkJBQTZCO0FBQUEsY0FDcEQ2RCxLQUFLMUMsU0FBUzBDO0FBQUFBLGNBQ2RDLEtBQUszQyxTQUFTMkM7QUFBQUEsWUFDaEIsQ0FBQztBQUNELG1CQUFPeEIsV0FBVzBCLFVBQVU7QUFBQSxVQUM5QjtBQUFBLFFBQ0YsRUFBRSxDQUNKO0FBQUEsTUFDRjtBQUFBLElBQ0YsQ0FBQztBQUFFVCw0QkFBQTlDLGFBQUE7QUFFSCxXQUFPYixTQUNMSCxLQUFLLE9BQU9hLFFBQVE7QUFDbEIsWUFBTTtBQUFBLFFBQUVtRDtBQUFBQSxRQUFRQztBQUFBQSxNQUFxQixJQUFJLE1BQU1wRCxJQUM3Q2lELHVCQUNGO0FBQ0EsWUFBTVUsV0FBV1AscUJBQXFCbkMsSUFBS3NCLE9BQU12QyxJQUFJdUMsQ0FBQyxDQUFDO0FBQ3ZELFlBQU1xQixPQUFPLE1BQU1DLFFBQVFDLElBQUlILFFBQVE7QUFFdkMsVUFBSUksTUFBTTtBQUNWLGVBQVMzQixJQUFJLEdBQUdBLElBQUl3QixLQUFLSSxRQUFRNUIsS0FBSztBQUVwQzJCLGVBQU9ILEtBQUt4QixDQUFDLEVBQUV3QixPQUFPVCxPQUFPZixDQUFDO0FBQUEsTUFDaEM7QUFDQSxhQUFPMkIsSUFBSUUsUUFBUSxDQUFDO0FBQUEsSUFDdEIsQ0FBQyxDQUNIO0FBQUEsRUFDRixHQUFHLEVBQUU7QUFDUCIsIm5hbWVzIjpbImF0b20iLCJ1c2VTZXRBdG9tIiwiYXRvbVdpdGhTdXNwZW5zZVF1ZXJ5IiwibG9hZGFibGUiLCJ1c2VFZmZlY3QiLCJ1c2VNZW1vIiwidXNlUmVmIiwiZmV0Y2hQYW5lbEVzdGltYXRlUHJvZHVjdGlvbiIsInZpcnR1YWxQYW5lbE9mZmVyJCIsInBvd2VyU3VwcGx5U2VsZWN0ZWRBdG9tIiwicGFuZWxzQXZhaWxhYmxlQXRvbSIsImdsb2JhbFRoaXMiLCJqb3RhaUF0b21DYWNoZSIsImdldCIsInYiLCJsb2NhdGlvbnMiLCJkZWJ1Z0xhYmVsIiwicGFuZWxzU2VsZWN0ZWRBdG9tIiwicGFuZWxzRGV0YWlsc0F0b20iLCJwYW5lbHNBdmFpbGFibGUiLCJwYW5lbHNTZWxlY3RlZCIsImdldExvY2F0aW9uQnlJZCIsImxvY2F0aW9uSWQiLCJmaW5kIiwiaWQiLCJnZXRTaXplQnlQcm9kdWN0SWQiLCJsb2NhdGlvbiIsInByb2R1Y3RJZCIsInNpemVzIiwic2l6ZSIsIm1hcCIsInBhbmVsSWQiLCJmaWx0ZXIiLCJ4IiwicGFuZWxzU2VsZWN0ZWREZXRhaWxzQXRvbSIsInBhbmVsQmVzdFNpemVBdG9tIiwic3VwcGx5IiwicGFuZWxCZXN0U2l6ZSIsInBhbmVsTG9jYXRpb25zQXRvbSIsImwiLCJzdWdnZXN0ZWRQYW5lbCIsImdldFN1Z2dlc3RlZFBhbmVsIiwiTWFwIiwic3VnZ2VzdGVkUG93ZXIiLCJiZXN0UG93ZXIiLCJwYXJzZUZsb2F0IiwiRVBTSUxPTiIsImluZGV4IiwicGFuZWwiLCJpIiwicG93ZXIiLCJzb3J0IiwiYSIsImIiLCJ1c2VFc3RpbWF0ZWRQcm9kdWN0aW9uQXRvbSIsInBhbmVscyIsInBhbmVsc0F0b20iLCJzZXQiLCJjdXJyZW50Iiwib2xkUGFuZWxzIiwiSlNPTiIsInN0cmluZ2lmeSIsImVzdGltYXRlZFByb2R1Y3Rpb25BdG9tIiwicGFuZWxzRGV0YWlscyIsInBvd2VycyIsImVzdGltYXRlZFByb2R1Y3Rpb25zIiwicmV0cnkiLCJxdWVyeUtleSIsImxhdCIsImxuZyIsInF1ZXJ5Rm4iLCJwcm9kdWN0aW9uIiwicHJvbWlzZXMiLCJkYXRhIiwiUHJvbWlzZSIsImFsbCIsInN1bSIsImxlbmd0aCIsInRvRml4ZWQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsicGFuZWxzLWF0b21zLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEF0b20sIGF0b20sIHVzZVNldEF0b20gfSBmcm9tICdqb3RhaSc7XHJcbmltcG9ydCB7IGF0b21XaXRoU3VzcGVuc2VRdWVyeSB9IGZyb20gJ2pvdGFpLXRhbnN0YWNrLXF1ZXJ5JztcclxuaW1wb3J0IHsgbG9hZGFibGUgfSBmcm9tICdqb3RhaS91dGlscyc7XHJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBmZXRjaFBhbmVsRXN0aW1hdGVQcm9kdWN0aW9uIH0gZnJvbSAnLi4vYXBpL3BhbmVsLWFkb3B0aW9uJztcclxuaW1wb3J0IHsgdmlydHVhbFBhbmVsT2ZmZXIkIH0gZnJvbSAnLi4vYXBpL3Byb2R1Y3RzLWNvbGxlY3Rpb24nO1xyXG5pbXBvcnQgeyBwb3dlclN1cHBseVNlbGVjdGVkQXRvbSB9IGZyb20gJy4vc3VwcGx5LXNlbGVjdGVkLXBvd2VyJztcclxuaW1wb3J0IHsgVmlydHVhbFBhbmVsU2VsZWN0ZWQsIFZpcnR1YWxQYW5lbFNpdGUgfSBmcm9tICcuL3R5cGVzJztcclxuXHJcbmV4cG9ydCBjb25zdCBwYW5lbHNBdmFpbGFibGVBdG9tID0gYXRvbShhc3luYyAoZ2V0KSA9PiB7XHJcbiAgY29uc3QgdiA9IGF3YWl0IGdldCh2aXJ0dWFsUGFuZWxPZmZlciQpO1xyXG4gIHJldHVybiB2Py5sb2NhdGlvbnM7XHJcbn0pO1xyXG5cclxuZXhwb3J0IHR5cGUgUGFuZWxTZWxlY3RlZCA9IHtcclxuICBsb2NhdGlvbklkOiBzdHJpbmc7XHJcbiAgcGFuZWxJZDogc3RyaW5nO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHBhbmVsc1NlbGVjdGVkQXRvbSA9IGF0b208UGFuZWxTZWxlY3RlZFtdPihbXSk7XHJcblxyXG5jb25zdCBwYW5lbHNEZXRhaWxzQXRvbSA9IChwYW5lbHNTZWxlY3RlZEF0b206IEF0b208UGFuZWxTZWxlY3RlZFtdPikgPT5cclxuICBhdG9tKGFzeW5jIChnZXQpID0+IHtcclxuICAgIGNvbnN0IHBhbmVsc0F2YWlsYWJsZSA9IGF3YWl0IGdldChwYW5lbHNBdmFpbGFibGVBdG9tKTtcclxuICAgIGNvbnN0IHBhbmVsc1NlbGVjdGVkID0gZ2V0KHBhbmVsc1NlbGVjdGVkQXRvbSk7XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0TG9jYXRpb25CeUlkKGxvY2F0aW9uSWQ6IHN0cmluZykge1xyXG4gICAgICByZXR1cm4gcGFuZWxzQXZhaWxhYmxlPy5maW5kKCh7IGlkIH0pID0+IGlkID09PSBsb2NhdGlvbklkKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRTaXplQnlQcm9kdWN0SWQobG9jYXRpb246IFZpcnR1YWxQYW5lbFNpdGUsIHByb2R1Y3RJZDogc3RyaW5nKSB7XHJcbiAgICAgIHJldHVybiBsb2NhdGlvbj8uc2l6ZXMuZmluZCgoc2l6ZSkgPT4gc2l6ZS5wcm9kdWN0SWQgPT09IHByb2R1Y3RJZCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBhbmVsc1NlbGVjdGVkXHJcbiAgICAgIC5tYXAoKHsgbG9jYXRpb25JZCwgcGFuZWxJZCB9KSA9PiB7XHJcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSBnZXRMb2NhdGlvbkJ5SWQobG9jYXRpb25JZCk7XHJcbiAgICAgICAgaWYgKCFsb2NhdGlvbikge1xyXG4gICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBzaXplID0gZ2V0U2l6ZUJ5UHJvZHVjdElkKGxvY2F0aW9uLCBwYW5lbElkKTtcclxuICAgICAgICBpZiAoIXNpemUpIHtcclxuICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgcGFuZWxzU2VsZWN0ZWQ6IFZpcnR1YWxQYW5lbFNlbGVjdGVkID0ge1xyXG4gICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxyXG4gICAgICAgICAgc2l6ZTogc2l6ZSxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gcGFuZWxzU2VsZWN0ZWQ7XHJcbiAgICAgIH0pXHJcbiAgICAgIC5maWx0ZXIoKHgpID0+ICEheCk7XHJcbiAgfSk7XHJcblxyXG5leHBvcnQgY29uc3QgcGFuZWxzU2VsZWN0ZWREZXRhaWxzQXRvbSA9IHBhbmVsc0RldGFpbHNBdG9tKHBhbmVsc1NlbGVjdGVkQXRvbSk7XHJcblxyXG5jb25zdCBwYW5lbEJlc3RTaXplQXRvbSA9IGF0b20oYXN5bmMgKGdldCkgPT4ge1xyXG4gIGNvbnN0IHN1cHBseSA9IGF3YWl0IGdldChwb3dlclN1cHBseVNlbGVjdGVkQXRvbSk7XHJcbiAgY29uc3QgcGFuZWxCZXN0U2l6ZSA9IHN1cHBseT8ucGFuZWxCZXN0U2l6ZTtcclxuICBpZiAoIXBhbmVsQmVzdFNpemUpIHJldHVybjtcclxuICByZXR1cm4gZ2V0KHBhbmVsQmVzdFNpemUpO1xyXG59KTtcclxuXHJcbmV4cG9ydCBjb25zdCBwYW5lbExvY2F0aW9uc0F0b20gPSBhdG9tKGFzeW5jIChnZXQpID0+IHtcclxuICBjb25zdCBsb2NhdGlvbnMgPSBhd2FpdCBnZXQocGFuZWxzQXZhaWxhYmxlQXRvbSk7XHJcbiAgY29uc3QgcGFuZWxCZXN0U2l6ZSA9IGF3YWl0IGdldChwYW5lbEJlc3RTaXplQXRvbSk7XHJcblxyXG4gIGNvbnN0IGwgPSBsb2NhdGlvbnNcclxuICAgID8ubWFwKChsb2NhdGlvbikgPT4gKHtcclxuICAgICAgLi4ubG9jYXRpb24sXHJcbiAgICAgIHN1Z2dlc3RlZFBhbmVsOiBnZXRTdWdnZXN0ZWRQYW5lbChsb2NhdGlvbiwgcGFuZWxCZXN0U2l6ZSk/LnByb2R1Y3RJZCxcclxuICAgIH0pKVxyXG4gICAgLm1hcCgobG9jYXRpb24pID0+IFtsb2NhdGlvbi5pZCwgbG9jYXRpb25dIGFzIGNvbnN0KTtcclxuXHJcbiAgcmV0dXJuIG5ldyBNYXAobCk7XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIHN1Z2dlc3RlZCBwYW5lbCBmb3IgdGhlIHVzZXIgZm9yIHRoZSBjdXJyZW50IGBsb2NhdGlvbmAgd2l0aCB0aGUgYHN1Z2dlc3RlZFBvd2VyYCByZXNwb25zZS5cclxuICpcclxuICogQHBhcmFtIGxvY2F0aW9uIGxvY2F0aW9uLnNpemVzIG11c3QgYmUgaW4gcG93ZXIgc29ydGVkIG9yZGVyXHJcbiAqIEBwYXJhbSBzdWdnZXN0ZWRQb3dlciBudW1iZXIgKG9yIG51bWJlciBpbnNpZGUgYSBzdHJpbmcpIHRoYXQgaW5kaWNhdGVzIHRoZSBiZXN0IHBvd2VyXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRTdWdnZXN0ZWRQYW5lbChcclxuICBsb2NhdGlvbjogVmlydHVhbFBhbmVsU2l0ZSxcclxuICBzdWdnZXN0ZWRQb3dlcjogc3RyaW5nIHwgdW5kZWZpbmVkXHJcbikge1xyXG4gIGlmICghc3VnZ2VzdGVkUG93ZXIpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgY29uc3QgYmVzdFBvd2VyID0gcGFyc2VGbG9hdChzdWdnZXN0ZWRQb3dlcik7XHJcblxyXG4gIC8vIFdlIGhhdmUgY29tcGFyaXNvbnMgd2l0aCBmbG9hdHMsIHRoaXMgcHJldmVudHMgcHJlY2lzaW9ucyBpc3N1ZXMuXHJcbiAgY29uc3QgRVBTSUxPTiA9IDAuMDE7XHJcblxyXG4gIGNvbnN0IGluZGV4ID0gbG9jYXRpb24uc2l6ZXNcclxuICAgIC5tYXAoKHBhbmVsLCBpKSA9PiAoeyBwb3dlcjogcGFyc2VGbG9hdChwYW5lbC5wb3dlciksIGkgfSkpXHJcbiAgICAuZmlsdGVyKCh7IHBvd2VyIH0pID0+IHBvd2VyIDwgYmVzdFBvd2VyICsgRVBTSUxPTilcclxuICAgIC5zb3J0KChhLCBiKSA9PiBiLnBvd2VyIC0gYS5wb3dlcilbMF0/Lmk7XHJcblxyXG4gIC8vIElmIHdlIGNhbm5vdCBmaW5kIGEgc2l6ZSwgd2Ugc3VnZ2VzdCB0aGUgb25lIHdpdGggdGhlIGxvd2VzdCBwb3dlci5cclxuICByZXR1cm4gaW5kZXggIT0gbnVsbCA/IGxvY2F0aW9uLnNpemVzW2luZGV4XSA6IGxvY2F0aW9uLnNpemVzWzBdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlRXN0aW1hdGVkUHJvZHVjdGlvbkF0b20ocGFuZWxzPzogUGFuZWxTZWxlY3RlZFtdKSB7XHJcbiAgY29uc3QgcGFuZWxzQXRvbSA9IHVzZVJlZihhdG9tKFtdIGFzIFBhbmVsU2VsZWN0ZWRbXSkpO1xyXG4gIGNvbnN0IHNldCA9IHVzZVNldEF0b20ocGFuZWxzQXRvbS5jdXJyZW50KTtcclxuXHJcbiAgY29uc3Qgb2xkUGFuZWxzID0gdXNlUmVmPHN0cmluZz4oKTtcclxuICAvLyBUT0RPIGZpeG1lISByZWFjdCBob29rIGZvcm0gZG8gbm90IHVwZGF0ZSBhcnJheS5cclxuICAvLyAgU28gSSBoYXZlIG9taXR0ZWQgYFtwYW5lbHNdYCBkZXBlbmRlbmN5IGFycmF5IGFuZCBJJ20gY3JlYXRpbmcgZXZlcnl0aW1lIGEgbmV3IG9iamVjdCFcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKHBhbmVscykge1xyXG4gICAgICBjb25zdCBjdXJyZW50ID0gSlNPTi5zdHJpbmdpZnkocGFuZWxzKTtcclxuICAgICAgaWYgKG9sZFBhbmVscy5jdXJyZW50ICE9PSBjdXJyZW50KSB7XHJcbiAgICAgICAgb2xkUGFuZWxzLmN1cnJlbnQgPSBjdXJyZW50O1xyXG4gICAgICAgIHNldChbLi4ucGFuZWxzXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIHVzZU1lbW8oKCkgPT4ge1xyXG4gICAgY29uc3QgZXN0aW1hdGVkUHJvZHVjdGlvbkF0b20gPSBhdG9tKGFzeW5jIChnZXQpID0+IHtcclxuICAgICAgY29uc3QgcGFuZWxzRGV0YWlscyA9IGF3YWl0IGdldChwYW5lbHNEZXRhaWxzQXRvbShwYW5lbHNBdG9tLmN1cnJlbnQpKTtcclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgcG93ZXJzOiBwYW5lbHNEZXRhaWxzLm1hcCgoeyBzaXplIH0pID0+IHBhcnNlRmxvYXQoc2l6ZS5wb3dlcikpLFxyXG4gICAgICAgIGVzdGltYXRlZFByb2R1Y3Rpb25zOiBwYW5lbHNEZXRhaWxzLm1hcCgoeyBsb2NhdGlvbiB9KSA9PlxyXG4gICAgICAgICAgYXRvbVdpdGhTdXNwZW5zZVF1ZXJ5KCgpID0+ICh7XHJcbiAgICAgICAgICAgIHJldHJ5OiAwLFxyXG4gICAgICAgICAgICBxdWVyeUtleTogWydsb2NhdGlvbicsIGxvY2F0aW9uLmxhdCwgbG9jYXRpb24ubG5nXSxcclxuICAgICAgICAgICAgcXVlcnlGbjogYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHByb2R1Y3Rpb24gPSBhd2FpdCBmZXRjaFBhbmVsRXN0aW1hdGVQcm9kdWN0aW9uKHtcclxuICAgICAgICAgICAgICAgIGxhdDogbG9jYXRpb24ubGF0LFxyXG4gICAgICAgICAgICAgICAgbG5nOiBsb2NhdGlvbi5sbmcsXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQocHJvZHVjdGlvbik7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICB9KSlcclxuICAgICAgICApLFxyXG4gICAgICB9O1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGxvYWRhYmxlKFxyXG4gICAgICBhdG9tKGFzeW5jIChnZXQpID0+IHtcclxuICAgICAgICBjb25zdCB7IHBvd2VycywgZXN0aW1hdGVkUHJvZHVjdGlvbnMgfSA9IGF3YWl0IGdldChcclxuICAgICAgICAgIGVzdGltYXRlZFByb2R1Y3Rpb25BdG9tXHJcbiAgICAgICAgKTtcclxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IGVzdGltYXRlZFByb2R1Y3Rpb25zLm1hcCgoYSkgPT4gZ2V0KGEpKTtcclxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xyXG5cclxuICAgICAgICBsZXQgc3VtID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdGhlc2UgaW5kZXhlcyBhcmUgc2FmZVxyXG4gICAgICAgICAgc3VtICs9IGRhdGFbaV0uZGF0YSAqIHBvd2Vyc1tpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN1bS50b0ZpeGVkKDApO1xyXG4gICAgICB9KVxyXG4gICAgKTtcclxuICB9LCBbXSk7XHJcbn1cclxuIl0sImZpbGUiOiJDOi9Vc2Vycy9haW50cm9uYS9EZXNrdG9wL0FwcC9yZWFjdC9uYWovbGlicy9kYXRhLWFjY2Vzcy9zcmMvbGliL2F0b21zL3BhbmVscy1hdG9tcy50cyJ9