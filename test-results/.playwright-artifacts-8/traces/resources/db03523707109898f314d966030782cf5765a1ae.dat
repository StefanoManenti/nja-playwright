globalThis.jotaiAtomCache = globalThis.jotaiAtomCache || { cache: /* @__PURE__ */ new Map(), get(name, inst) {
  if (this.cache.has(name)) {
    return this.cache.get(name);
  }
  this.cache.set(name, inst);
  return inst;
} };
import { broadband$, workingOnBroadbandAtom } from "/@fs/C:/Users/aintrona/Desktop/App/react/naj/libs/data-access/src/index.ts";
import { Step, StepPriority } from "/@fs/C:/Users/aintrona/Desktop/App/react/naj/libs/engine/src/index.ts";
import StepErrorBoundary from "/@fs/C:/Users/aintrona/Desktop/App/react/naj/libs/steps/src/lib/StepErrorBoundary.tsx";
import { StepDependencies } from "/@fs/C:/Users/aintrona/Desktop/App/react/naj/libs/steps/src/lib/StepDependencies.ts";
class BroadbandEffectiveDates extends Step {
  constructor() {
    super(...arguments);
    this.priority = new StepPriority(91);
    this.skipIfDone = false;
    this.lazy = () => import("/@fs/C:/Users/aintrona/Desktop/App/react/naj/libs/steps/src/lib/effective-dates/BroadbandEffectiveDatesStep.tsx");
    this.WrapperComponent = StepErrorBoundary;
  }
  toString() {
    return "effectiveDatesFiber";
  }
  depends() {
    return [];
  }
  provides() {
    return [StepDependencies.BROADBAND_IMMEDIATE_EFFECT];
  }
  isInFlux(get) {
    return get(workingOnBroadbandAtom);
  }
  async isAvailable(get) {
    const broadband = await get(broadband$);
    const effectiveDates = await get(broadband.effectiveDates$);
    return !!effectiveDates && Object.keys(effectiveDates).length > 1;
  }
  async toDo(get) {
    const broadband = await get(broadband$);
    const immediateEffect = await get(broadband.immediateEffect$);
    return !immediateEffect;
  }
}
export const effectiveDatesFiber = new BroadbandEffectiveDates();

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLFNBQVNBLFlBQVlDLDhCQUE4QjtBQUNuRCxTQUFTQyxNQUFNQyxvQkFBb0I7QUFFbkMsT0FBT0MsdUJBQXVCO0FBQzlCLFNBQVNDLHdCQUF3QjtBQUVqQyxNQUFNQyxnQ0FBZ0NKLEtBQUs7QUFBQSxFQUEzQztBQUFBO0FBQ0VLLG9CQUFXLElBQUlKLGFBQWEsRUFBRTtBQUM5Qkssc0JBQWE7QUFFYkMsZ0JBQU9BLE1BQU0sT0FBTywrQkFBK0I7QUFDbkRDLDRCQUFtQk47QUFBQUE7QUFBQUEsRUFFbkJPLFdBQVc7QUFDVCxXQUFPO0FBQUEsRUFDVDtBQUFBLEVBRUFDLFVBQVU7QUFDUixXQUFPO0FBQUEsRUFDVDtBQUFBLEVBRUFDLFdBQVc7QUFDVCxXQUFPLENBQUNSLGlCQUFpQlMsMEJBQTBCO0FBQUEsRUFDckQ7QUFBQSxFQUVVQyxTQUFTQyxLQUFhO0FBQzlCLFdBQU9BLElBQUlmLHNCQUFzQjtBQUFBLEVBQ25DO0FBQUEsRUFFQSxNQUFnQmdCLFlBQVlELEtBQWE7QUFDdkMsVUFBTUUsWUFBWSxNQUFNRixJQUFJaEIsVUFBVTtBQUN0QyxVQUFNbUIsaUJBQWlCLE1BQU1ILElBQUlFLFVBQVVFLGVBQWU7QUFFMUQsV0FBTyxDQUFDLENBQUNELGtCQUFrQkUsT0FBT0MsS0FBS0gsY0FBYyxFQUFFSSxTQUFTO0FBQUEsRUFDbEU7QUFBQSxFQUVBLE1BQWdCQyxLQUFLUixLQUFhO0FBQ2hDLFVBQU1FLFlBQVksTUFBTUYsSUFBSWhCLFVBQVU7QUFDdEMsVUFBTXlCLGtCQUFrQixNQUFNVCxJQUFJRSxVQUFVUSxnQkFBZ0I7QUFDNUQsV0FBTyxDQUFDRDtBQUFBQSxFQUNWO0FBQ0Y7QUFFTyxhQUFNRSxzQkFBc0IsSUFBSXJCLHdCQUF3QiIsIm5hbWVzIjpbImJyb2FkYmFuZCQiLCJ3b3JraW5nT25Ccm9hZGJhbmRBdG9tIiwiU3RlcCIsIlN0ZXBQcmlvcml0eSIsIlN0ZXBFcnJvckJvdW5kYXJ5IiwiU3RlcERlcGVuZGVuY2llcyIsIkJyb2FkYmFuZEVmZmVjdGl2ZURhdGVzIiwicHJpb3JpdHkiLCJza2lwSWZEb25lIiwibGF6eSIsIldyYXBwZXJDb21wb25lbnQiLCJ0b1N0cmluZyIsImRlcGVuZHMiLCJwcm92aWRlcyIsIkJST0FEQkFORF9JTU1FRElBVEVfRUZGRUNUIiwiaXNJbkZsdXgiLCJnZXQiLCJpc0F2YWlsYWJsZSIsImJyb2FkYmFuZCIsImVmZmVjdGl2ZURhdGVzIiwiZWZmZWN0aXZlRGF0ZXMkIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsInRvRG8iLCJpbW1lZGlhdGVFZmZlY3QiLCJpbW1lZGlhdGVFZmZlY3QkIiwiZWZmZWN0aXZlRGF0ZXNGaWJlciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyJicm9hZGJhbmQtZWZmZWN0aXZlLWRhdGVzLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBicm9hZGJhbmQkLCB3b3JraW5nT25Ccm9hZGJhbmRBdG9tIH0gZnJvbSAnQG5hai13by9kYXRhLWFjY2Vzcyc7XHJcbmltcG9ydCB7IFN0ZXAsIFN0ZXBQcmlvcml0eSB9IGZyb20gJ0BuYWotd28vZW5naW5lJztcclxuaW1wb3J0IHsgR2V0dGVyIH0gZnJvbSAnam90YWkvdmFuaWxsYS90eXBlVXRpbHMnO1xyXG5pbXBvcnQgU3RlcEVycm9yQm91bmRhcnkgZnJvbSAnLi4vU3RlcEVycm9yQm91bmRhcnknO1xyXG5pbXBvcnQgeyBTdGVwRGVwZW5kZW5jaWVzIH0gZnJvbSAnLi4vU3RlcERlcGVuZGVuY2llcyc7XHJcblxyXG5jbGFzcyBCcm9hZGJhbmRFZmZlY3RpdmVEYXRlcyBleHRlbmRzIFN0ZXAge1xyXG4gIHByaW9yaXR5ID0gbmV3IFN0ZXBQcmlvcml0eSg5MSk7XHJcbiAgc2tpcElmRG9uZSA9IGZhbHNlO1xyXG5cclxuICBsYXp5ID0gKCkgPT4gaW1wb3J0KCcuL0Jyb2FkYmFuZEVmZmVjdGl2ZURhdGVzU3RlcCcpO1xyXG4gIFdyYXBwZXJDb21wb25lbnQgPSBTdGVwRXJyb3JCb3VuZGFyeTtcclxuXHJcbiAgdG9TdHJpbmcoKSB7XHJcbiAgICByZXR1cm4gJ2VmZmVjdGl2ZURhdGVzRmliZXInO1xyXG4gIH1cclxuXHJcbiAgZGVwZW5kcygpIHtcclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcblxyXG4gIHByb3ZpZGVzKCkge1xyXG4gICAgcmV0dXJuIFtTdGVwRGVwZW5kZW5jaWVzLkJST0FEQkFORF9JTU1FRElBVEVfRUZGRUNUXTtcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBpc0luRmx1eChnZXQ6IEdldHRlcikge1xyXG4gICAgcmV0dXJuIGdldCh3b3JraW5nT25Ccm9hZGJhbmRBdG9tKTtcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBhc3luYyBpc0F2YWlsYWJsZShnZXQ6IEdldHRlcikge1xyXG4gICAgY29uc3QgYnJvYWRiYW5kID0gYXdhaXQgZ2V0KGJyb2FkYmFuZCQpO1xyXG4gICAgY29uc3QgZWZmZWN0aXZlRGF0ZXMgPSBhd2FpdCBnZXQoYnJvYWRiYW5kLmVmZmVjdGl2ZURhdGVzJCk7XHJcbiAgICAvLyBIaWRlIHRoZSBzdGVwIGlmIHdlIGRvbid0IGhhdmUgY2hvaWNlLlxyXG4gICAgcmV0dXJuICEhZWZmZWN0aXZlRGF0ZXMgJiYgT2JqZWN0LmtleXMoZWZmZWN0aXZlRGF0ZXMpLmxlbmd0aCA+IDE7XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgYXN5bmMgdG9EbyhnZXQ6IEdldHRlcikge1xyXG4gICAgY29uc3QgYnJvYWRiYW5kID0gYXdhaXQgZ2V0KGJyb2FkYmFuZCQpO1xyXG4gICAgY29uc3QgaW1tZWRpYXRlRWZmZWN0ID0gYXdhaXQgZ2V0KGJyb2FkYmFuZC5pbW1lZGlhdGVFZmZlY3QkKTtcclxuICAgIHJldHVybiAhaW1tZWRpYXRlRWZmZWN0O1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGVmZmVjdGl2ZURhdGVzRmliZXIgPSBuZXcgQnJvYWRiYW5kRWZmZWN0aXZlRGF0ZXMoKTtcclxuIl0sImZpbGUiOiJDOi9Vc2Vycy9haW50cm9uYS9EZXNrdG9wL0FwcC9yZWFjdC9uYWovbGlicy9zdGVwcy9zcmMvbGliL2VmZmVjdGl2ZS1kYXRlcy9icm9hZGJhbmQtZWZmZWN0aXZlLWRhdGVzLnRzeCJ9