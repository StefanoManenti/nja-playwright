import {
  require_react
} from "/@fs/C:/Users/aintrona/Desktop/App/react/naj/node_modules/.vite/apps/naj/deps/chunk-GAIRWVJN.js?v=0189a8d1";
import {
  __toESM
} from "/@fs/C:/Users/aintrona/Desktop/App/react/naj/node_modules/.vite/apps/naj/deps/chunk-OL46QLBJ.js?v=0189a8d1";

// ../../node_modules/@mui/base/useTransition/TransitionContext.js
var React = __toESM(require_react());
var TransitionContext = React.createContext(null);
if (true) {
  TransitionContext.displayName = "TransitionContext";
}

// ../../node_modules/@mui/base/useTransition/useTransitionTrigger.js
var React2 = __toESM(require_react());
function useTransitionTrigger(requestEnter) {
  const [exitTransitionFinished, setExitTransitionFinished] = React2.useState(true);
  const hasPendingExitTransition = React2.useRef(false);
  const registeredTransitions = React2.useRef(0);
  const [hasTransition, setHasTransition] = React2.useState(false);
  const previousRequestEnter = React2.useRef(requestEnter);
  React2.useEffect(() => {
    if (!requestEnter && // checking registeredTransitions.current instead of hasTransition to avoid this effect re-firing whenever hasTransition changes
    registeredTransitions.current > 0 && // prevents waiting for a pending transition right after mounting
    previousRequestEnter.current !== requestEnter) {
      hasPendingExitTransition.current = true;
      setExitTransitionFinished(false);
    }
    previousRequestEnter.current = requestEnter;
  }, [requestEnter]);
  const handleExited = React2.useCallback(() => {
    hasPendingExitTransition.current = false;
    setExitTransitionFinished(true);
  }, []);
  const registerTransition = React2.useCallback(() => {
    registeredTransitions.current += 1;
    setHasTransition(true);
    return () => {
      registeredTransitions.current -= 1;
      if (registeredTransitions.current === 0) {
        setHasTransition(false);
      }
    };
  }, []);
  let hasExited;
  if (!hasTransition) {
    hasExited = !requestEnter;
  } else if (requestEnter) {
    hasExited = false;
  } else {
    hasExited = !hasPendingExitTransition.current && exitTransitionFinished;
  }
  const contextValue = React2.useMemo(() => ({
    requestedEnter: requestEnter,
    onExited: handleExited,
    registerTransition,
    hasExited
  }), [handleExited, requestEnter, registerTransition, hasExited]);
  return {
    contextValue,
    hasExited
  };
}

// ../../node_modules/@mui/base/useTransition/useTransitionStateManager.js
var React3 = __toESM(require_react());
function useTransitionStateManager() {
  const transitionContext = React3.useContext(TransitionContext);
  if (!transitionContext) {
    throw new Error("Missing transition context");
  }
  const {
    registerTransition,
    requestedEnter,
    onExited
  } = transitionContext;
  React3.useEffect(() => {
    return registerTransition();
  }, [registerTransition]);
  return {
    onExited,
    requestedEnter
  };
}

export {
  TransitionContext,
  useTransitionStateManager,
  useTransitionTrigger
};
//# sourceMappingURL=chunk-DHW3RBWR.js.map
