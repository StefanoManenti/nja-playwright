import {
  __export
} from "/@fs/C:/Users/aintrona/Desktop/App/react/naj/node_modules/.vite/apps/naj/deps/chunk-OL46QLBJ.js?v=0189a8d1";

// ../../node_modules/true-myth/dist/es/maybe.js
var maybe_exports = {};
__export(maybe_exports, {
  Maybe: () => Maybe,
  Variant: () => Variant,
  and: () => and,
  andThen: () => andThen,
  ap: () => ap,
  default: () => maybe_default,
  equals: () => equals,
  find: () => find,
  first: () => first,
  get: () => get,
  isInstance: () => isInstance,
  isJust: () => isJust,
  isNothing: () => isNothing,
  just: () => just,
  last: () => last,
  map: () => map,
  mapOr: () => mapOr,
  mapOrElse: () => mapOrElse,
  match: () => match,
  nothing: () => nothing,
  of: () => of,
  or: () => or,
  orElse: () => orElse,
  property: () => property,
  toJSON: () => toJSON,
  toString: () => toString,
  transposeArray: () => transposeArray,
  unwrapOr: () => unwrapOr,
  unwrapOrElse: () => unwrapOrElse,
  wrapReturn: () => wrapReturn
});

// ../../node_modules/true-myth/dist/es/-private/utils.js
var isVoid = (value) => typeof value === "undefined" || value === null;
function curry1(op, item) {
  return item !== void 0 ? op(item) : op;
}
function has(value, key) {
  return typeof value === "object" && value !== null && key in value;
}
function safeToString(value) {
  if (has(value, "toString") && typeof value["toString"] === "function") {
    const fnResult = value.toString();
    return typeof fnResult === "string" ? fnResult : JSON.stringify(value);
  } else {
    return JSON.stringify(value);
  }
}

// ../../node_modules/true-myth/dist/es/maybe.js
var Variant = {
  Just: "Just",
  Nothing: "Nothing"
};
var NOTHING;
var MaybeImpl = class _MaybeImpl {
  constructor(value) {
    if (isVoid(value)) {
      if (!NOTHING) {
        this.repr = [Variant.Nothing];
        NOTHING = this;
      }
      return NOTHING;
    } else {
      this.repr = [Variant.Just, value];
    }
  }
  // Then the implementation signature is simply the same as the final overload,
  // because we do not *and cannot* prevent the undesired function types from
  // appearing here at runtime: doing so would require having a value on which
  // to (maybe) apply the function!
  static of(value) {
    return new Maybe(value);
  }
  // The runtime signature *does* allow null and undefined values so that the
  // body can correctly throw at runtime in the case where a caller passes data
  // whose type lies about the contained value.
  static just(value) {
    if (isVoid(value)) {
      throw new Error(`attempted to call "just" with ${value}`);
    }
    return new Maybe(value);
  }
  /**
      Create an instance of `Maybe.Nothing`.
  
      If you want to create an instance with a specific type, e.g. for use in a
      function which expects a `Maybe<T>` where the `<T>` is known but you have no
      value to give it, you can use a type parameter:
  
      ```ts
      const notString = Maybe.nothing<string>();
      ```
  
      @template T The type of the item contained in the `Maybe`.
      @returns     An instance of `Maybe.Nothing<T>`.
     */
  static nothing(_) {
    return new _MaybeImpl();
  }
  /** Distinguish between the `Just` and `Nothing` {@link Variant variants}. */
  get variant() {
    return this.repr[0];
  }
  /**
      The wrapped value.
  
      @warning throws if you access this from a {@linkcode Just}
     */
  get value() {
    if (this.repr[0] === Variant.Nothing) {
      throw new Error("Cannot get the value of `Nothing`");
    }
    return this.repr[1];
  }
  /** Is the {@linkcode Maybe} a {@linkcode Just}? */
  get isJust() {
    return this.repr[0] === Variant.Just;
  }
  /** Is the {@linkcode Maybe} a {@linkcode Nothing}? */
  get isNothing() {
    return this.repr[0] === Variant.Nothing;
  }
  /** Method variant for {@linkcode map} */
  map(mapFn) {
    return this.repr[0] === "Just" ? Maybe.just(mapFn(this.repr[1])) : this;
  }
  /** Method variant for {@link mapOr|`mapOr`} */
  mapOr(orU, mapFn) {
    return this.repr[0] === "Just" ? mapFn(this.repr[1]) : orU;
  }
  /** Method variant for {@linkcode mapOrElse} */
  mapOrElse(orElseFn, mapFn) {
    return this.repr[0] === "Just" ? mapFn(this.repr[1]) : orElseFn();
  }
  /** Method variant for {@linkcode match} */
  match(matcher) {
    return this.repr[0] === "Just" ? matcher.Just(this.repr[1]) : matcher.Nothing();
  }
  /** Method variant for {@linkcode or} */
  or(mOr) {
    return this.repr[0] === "Just" ? this : mOr;
  }
  /** Method variant for {@linkcode orElse} */
  orElse(orElseFn) {
    return this.repr[0] === "Just" ? this : orElseFn();
  }
  /** Method variant for {@linkcode and} */
  and(mAnd) {
    return this.repr[0] === "Just" ? mAnd : this;
  }
  /** Method variant for {@linkcode andThen} */
  andThen(andThenFn) {
    return this.repr[0] === "Just" ? andThenFn(this.repr[1]) : this;
  }
  /** Method variant for {@linkcode unwrapOr} */
  unwrapOr(defaultValue) {
    return this.repr[0] === "Just" ? this.repr[1] : defaultValue;
  }
  /** Method variant for {@linkcode unwrapOrElse} */
  unwrapOrElse(elseFn) {
    return this.repr[0] === "Just" ? this.repr[1] : elseFn();
  }
  /** Method variant for {@linkcode toString} */
  toString() {
    return this.repr[0] === "Just" ? `Just(${safeToString(this.repr[1])})` : "Nothing";
  }
  /** Method variant for {@linkcode toJSON} */
  toJSON() {
    const variant = this.repr[0];
    if (variant === "Just") {
      let value = isInstance(this.repr[1]) ? this.repr[1].toJSON() : this.repr[1];
      return { variant, value };
    } else {
      return { variant };
    }
  }
  /** Method variant for {@linkcode equals} */
  equals(comparison) {
    return this.repr[0] === comparison.repr[0] && this.repr[1] === comparison.repr[1];
  }
  /** Method variant for {@linkcode ap} */
  ap(val) {
    return val.andThen((val2) => this.map((fn) => fn(val2)));
  }
  /**
      Method variant for {@linkcode get}
  
      If you have a `Maybe` of an object type, you can do `thatMaybe.get('a key')`
      to look up the next layer down in the object.
  
      ```ts
      type DeepOptionalType = {
        something?: {
          with?: {
            deeperKeys?: string;
          }
        }
      };
  
      const fullySet: DeepType = {
        something: {
          with: {
            deeperKeys: 'like this'
          }
        }
      };
  
      const deepJust = Maybe.of(fullySet)
        .get('something')
        .get('with')
        .get('deeperKeys');
  
      console.log(deepJust); // Just('like this');
  
      const partiallyUnset: DeepType = { something: { } };
  
      const deepEmpty = Maybe.of(partiallyUnset)
        .get('something')
        .get('with')
        .get('deeperKeys');
  
      console.log(deepEmpty); // Nothing
      ```
     */
  get(key) {
    return this.andThen(property(key));
  }
};
var just = MaybeImpl.just;
function isJust(maybe) {
  return maybe.isJust;
}
function isNothing(maybe) {
  return maybe.isNothing;
}
var nothing = MaybeImpl.nothing;
var of = MaybeImpl.of;
function map(mapFn, maybe) {
  const op = (m) => m.map(mapFn);
  return curry1(op, maybe);
}
function mapOr(orU, mapFn, maybe) {
  function fullOp(fn, m) {
    return m.mapOr(orU, fn);
  }
  function partialOp(fn, curriedMaybe) {
    return curriedMaybe !== void 0 ? fullOp(fn, curriedMaybe) : (extraCurriedMaybe) => fullOp(fn, extraCurriedMaybe);
  }
  return mapFn === void 0 ? partialOp : maybe === void 0 ? partialOp(mapFn) : partialOp(mapFn, maybe);
}
function mapOrElse(orElseFn, mapFn, maybe) {
  function fullOp(fn, m) {
    return m.mapOrElse(orElseFn, fn);
  }
  function partialOp(fn, curriedMaybe) {
    return curriedMaybe !== void 0 ? fullOp(fn, curriedMaybe) : (extraCurriedMaybe) => fullOp(fn, extraCurriedMaybe);
  }
  if (mapFn === void 0) {
    return partialOp;
  } else if (maybe === void 0) {
    return partialOp(mapFn);
  } else {
    return partialOp(mapFn, maybe);
  }
}
function and(andMaybe, maybe) {
  const op = (m) => m.and(andMaybe);
  return curry1(op, maybe);
}
function andThen(thenFn, maybe) {
  const op = (m) => m.andThen(thenFn);
  return maybe !== void 0 ? op(maybe) : op;
}
function or(defaultMaybe, maybe) {
  const op = (m) => m.or(defaultMaybe);
  return maybe !== void 0 ? op(maybe) : op;
}
function orElse(elseFn, maybe) {
  const op = (m) => m.orElse(elseFn);
  return curry1(op, maybe);
}
function unwrapOr(defaultValue, maybe) {
  const op = (m) => m.unwrapOr(defaultValue);
  return curry1(op, maybe);
}
function unwrapOrElse(orElseFn, maybe) {
  const op = (m) => m.unwrapOrElse(orElseFn);
  return curry1(op, maybe);
}
function toString(maybe) {
  return maybe.toString();
}
function toJSON(maybe) {
  return maybe.toJSON();
}
function match(matcher, maybe) {
  const op = (curriedMaybe) => curriedMaybe.match(matcher);
  return curry1(op, maybe);
}
function equals(mb, ma) {
  const op = (maybeA) => maybeA.equals(mb);
  return curry1(op, ma);
}
function ap(maybeFn, maybe) {
  const op = (m) => maybeFn.ap(m);
  return curry1(op, maybe);
}
function isInstance(item) {
  return item instanceof Maybe;
}
function find(predicate, array) {
  const op = (a) => Maybe.of(a.find(predicate));
  return curry1(op, array);
}
function first(array) {
  return Maybe.of(array[0]);
}
function last(array) {
  return Maybe.of(array[array.length - 1]);
}
function transposeArray(maybes) {
  return maybes.reduce((acc, m) => acc.andThen((ms) => m.map((m2) => [...ms, m2])), just([]));
}
function property(key, obj) {
  const op = (t) => Maybe.of(t[key]);
  return curry1(op, obj);
}
function get(key, maybeObj) {
  return curry1(andThen(property(key)), maybeObj);
}
function wrapReturn(fn) {
  return (...args) => Maybe.of(fn(...args));
}
var Maybe = MaybeImpl;
var maybe_default = Maybe;

// ../../node_modules/true-myth/dist/es/result.js
var result_exports = {};
__export(result_exports, {
  Result: () => Result,
  Variant: () => Variant2,
  and: () => and2,
  andThen: () => andThen2,
  ap: () => ap2,
  default: () => result_default,
  equals: () => equals2,
  err: () => err,
  isErr: () => isErr,
  isInstance: () => isInstance2,
  isOk: () => isOk,
  map: () => map2,
  mapErr: () => mapErr,
  mapOr: () => mapOr2,
  mapOrElse: () => mapOrElse2,
  match: () => match2,
  ok: () => ok,
  or: () => or2,
  orElse: () => orElse2,
  toJSON: () => toJSON2,
  toString: () => toString2,
  tryOr: () => tryOr,
  tryOrElse: () => tryOrElse,
  unwrapOr: () => unwrapOr2,
  unwrapOrElse: () => unwrapOrElse2
});

// ../../node_modules/true-myth/dist/es/unit.js
var Unit = /* @__PURE__ */ Object.create(null);
var unit_default = Unit;

// ../../node_modules/true-myth/dist/es/result.js
var Variant2 = {
  Ok: "Ok",
  Err: "Err"
};
var ResultImpl = class _ResultImpl {
  constructor(repr) {
    this.repr = repr;
  }
  static ok(value) {
    return arguments.length === 0 ? new _ResultImpl(["Ok", unit_default]) : (
      // SAFETY: TS does not understand that the arity check above accounts for
      // the case where the value is not passed.
      new _ResultImpl(["Ok", value])
    );
  }
  static err(error) {
    return isVoid(error) ? new _ResultImpl(["Err", unit_default]) : new _ResultImpl(["Err", error]);
  }
  /** Distinguish between the {@linkcode Variant.Ok} and {@linkcode Variant.Err} {@linkcode Variant variants}. */
  get variant() {
    return this.repr[0];
  }
  /**
      The wrapped value.
  
      @throws if you access when the {@linkcode Result} is not {@linkcode Ok}
     */
  get value() {
    if (this.repr[0] === Variant2.Err) {
      throw new Error("Cannot get the value of Err");
    }
    return this.repr[1];
  }
  /**
      The wrapped error value.
  
      @throws if you access when the {@linkcode Result} is not {@linkcode Err}
     */
  get error() {
    if (this.repr[0] === Variant2.Ok) {
      throw new Error("Cannot get the error of Ok");
    }
    return this.repr[1];
  }
  /** Is the {@linkcode Result} an {@linkcode Ok}? */
  get isOk() {
    return this.repr[0] === Variant2.Ok;
  }
  /** Is the `Result` an `Err`? */
  get isErr() {
    return this.repr[0] === Variant2.Err;
  }
  /** Method variant for {@linkcode map} */
  map(mapFn) {
    return this.repr[0] === "Ok" ? Result.ok(mapFn(this.repr[1])) : this;
  }
  /** Method variant for {@linkcode mapOr} */
  mapOr(orU, mapFn) {
    return this.repr[0] === "Ok" ? mapFn(this.repr[1]) : orU;
  }
  /** Method variant for {@linkcode mapOrElse} */
  mapOrElse(orElseFn, mapFn) {
    return this.repr[0] === "Ok" ? mapFn(this.repr[1]) : orElseFn(this.repr[1]);
  }
  /** Method variant for {@linkcode match} */
  match(matcher) {
    return this.repr[0] === "Ok" ? matcher.Ok(this.repr[1]) : matcher.Err(this.repr[1]);
  }
  /** Method variant for {@linkcode mapErr} */
  mapErr(mapErrFn) {
    return this.repr[0] === "Ok" ? this : Result.err(mapErrFn(this.repr[1]));
  }
  /** Method variant for {@linkcode or} */
  or(orResult) {
    return this.repr[0] === "Ok" ? this : orResult;
  }
  /** Method variant for {@linkcode orElse} */
  orElse(orElseFn) {
    return this.repr[0] === "Ok" ? this : orElseFn(this.repr[1]);
  }
  /** Method variant for {@linkcode and} */
  and(mAnd) {
    return this.repr[0] === "Ok" ? mAnd : this;
  }
  /** Method variant for {@linkcode andThen} */
  andThen(andThenFn) {
    return this.repr[0] === "Ok" ? andThenFn(this.repr[1]) : this;
  }
  /** Method variant for {@linkcode unwrapOr} */
  unwrapOr(defaultValue) {
    return this.repr[0] === "Ok" ? this.repr[1] : defaultValue;
  }
  /** Method variant for {@linkcode unwrapOrElse} */
  unwrapOrElse(elseFn) {
    return this.repr[0] === "Ok" ? this.repr[1] : elseFn(this.repr[1]);
  }
  /** Method variant for {@linkcode toString} */
  toString() {
    return `${this.repr[0]}(${safeToString(this.repr[1])})`;
  }
  /** Method variant for {@linkcode toJSON} */
  toJSON() {
    const variant = this.repr[0];
    return variant === "Ok" ? { variant, value: this.repr[1] } : { variant, error: this.repr[1] };
  }
  /** Method variant for {@linkcode equals} */
  equals(comparison) {
    return this.repr[0] === comparison.repr[0] && this.repr[1] === comparison.repr[1];
  }
  /** Method variant for {@linkcode ap} */
  ap(r) {
    return r.andThen((val) => this.map((fn) => fn(val)));
  }
  cast() {
    return this;
  }
};
function tryOr(error, callback) {
  const op = (cb) => {
    try {
      return ok(cb());
    } catch {
      return err(error);
    }
  };
  return curry1(op, callback);
}
var ok = ResultImpl.ok;
function isOk(result) {
  return result.isOk;
}
function isErr(result) {
  return result.isErr;
}
var err = ResultImpl.err;
function tryOrElse(onError, callback) {
  const op = (cb) => {
    try {
      return ok(cb());
    } catch (e) {
      return err(onError(e));
    }
  };
  return curry1(op, callback);
}
function map2(mapFn, result) {
  const op = (r) => r.map(mapFn);
  return curry1(op, result);
}
function mapOr2(orU, mapFn, result) {
  function fullOp(fn, r) {
    return r.mapOr(orU, fn);
  }
  function partialOp(fn, curriedResult) {
    return curriedResult !== void 0 ? fullOp(fn, curriedResult) : (extraCurriedResult) => fullOp(fn, extraCurriedResult);
  }
  return mapFn === void 0 ? partialOp : result === void 0 ? partialOp(mapFn) : partialOp(mapFn, result);
}
function mapOrElse2(orElseFn, mapFn, result) {
  function fullOp(fn, r) {
    return r.mapOrElse(orElseFn, fn);
  }
  function partialOp(fn, curriedResult) {
    return curriedResult !== void 0 ? fullOp(fn, curriedResult) : (extraCurriedResult) => fullOp(fn, extraCurriedResult);
  }
  return mapFn === void 0 ? partialOp : result === void 0 ? partialOp(mapFn) : partialOp(mapFn, result);
}
function mapErr(mapErrFn, result) {
  const op = (r) => r.mapErr(mapErrFn);
  return curry1(op, result);
}
function and2(andResult, result) {
  const op = (r) => r.and(andResult);
  return curry1(op, result);
}
function andThen2(thenFn, result) {
  const op = (r) => r.andThen(thenFn);
  return curry1(op, result);
}
function or2(defaultResult, result) {
  const op = (r) => r.or(defaultResult);
  return curry1(op, result);
}
function orElse2(elseFn, result) {
  const op = (r) => r.orElse(elseFn);
  return curry1(op, result);
}
function unwrapOr2(defaultValue, result) {
  const op = (r) => r.unwrapOr(defaultValue);
  return curry1(op, result);
}
function unwrapOrElse2(orElseFn, result) {
  const op = (r) => r.unwrapOrElse(orElseFn);
  return curry1(op, result);
}
var toString2 = (result) => {
  return result.toString();
};
var toJSON2 = (result) => {
  return result.toJSON();
};
function match2(matcher, result) {
  const op = (r) => r.mapOrElse(matcher.Err, matcher.Ok);
  return curry1(op, result);
}
function equals2(resultB, resultA) {
  const op = (rA) => rA.equals(resultB);
  return curry1(op, resultA);
}
function ap2(resultFn, result) {
  const op = (r) => resultFn.ap(r);
  return curry1(op, result);
}
function isInstance2(item) {
  return item instanceof ResultImpl;
}
var Result = ResultImpl;
var result_default = Result;

// ../../node_modules/true-myth/dist/es/toolbelt.js
var toolbelt_exports = {};
__export(toolbelt_exports, {
  fromMaybe: () => fromMaybe,
  fromResult: () => fromResult,
  toMaybe: () => toMaybe,
  toOkOrElseErr: () => toOkOrElseErr,
  toOkOrErr: () => toOkOrErr,
  transposeMaybe: () => transposeMaybe,
  transposeResult: () => transposeResult
});
function transposeResult(result) {
  return result.match({
    Ok: (maybe) => maybe.match({
      Just: (v) => maybe_default.just(result_default.ok(v)),
      Nothing: () => maybe_default.nothing()
    }),
    Err: (e) => maybe_default.just(result_default.err(e))
  });
}
function toMaybe(result) {
  return result.isOk ? maybe_default.just(result.value) : maybe_default.nothing();
}
function fromMaybe(errValue, maybe) {
  const op = (m) => m.isJust ? result_default.ok(m.value) : result_default.err(errValue);
  return curry1(op, maybe);
}
function transposeMaybe(maybe) {
  return maybe.match({
    Just: (result) => result.match({
      Ok: (v) => result_default.ok(maybe_default.just(v)),
      Err: (e) => result_default.err(e)
    }),
    Nothing: () => result_default.ok(maybe_default.nothing())
  });
}
function toOkOrErr(error, maybe) {
  const op = (m) => m.isJust ? result_default.ok(m.value) : result_default.err(error);
  return maybe !== void 0 ? op(maybe) : op;
}
function toOkOrElseErr(elseFn, maybe) {
  const op = (m) => m.isJust ? result_default.ok(m.value) : result_default.err(elseFn());
  return curry1(op, maybe);
}
function fromResult(result) {
  return result.isOk ? maybe_default.just(result.value) : maybe_default.nothing();
}
export {
  maybe_default as Maybe,
  maybe_exports as MaybeNS,
  result_default as Result,
  result_exports as ResultNS,
  toolbelt_exports as Toolbelt,
  unit_default as Unit
};
//# sourceMappingURL=true-myth.js.map
