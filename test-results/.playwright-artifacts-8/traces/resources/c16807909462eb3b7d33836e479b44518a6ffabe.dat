import.meta.env = {"BASE_URL": "/", "DEV": true, "MODE": "development", "PROD": false, "SSR": false};globalThis.jotaiAtomCache = globalThis.jotaiAtomCache || {
  cache: /* @__PURE__ */ new Map(),
  get(name, inst) {
    if (this.cache.has(name)) {
      return this.cache.get(name);
    }
    this.cache.set(name, inst);
    return inst;
  }
};
import { tryAsyncOrF } from "/@fs/C:/Users/aintrona/Desktop/App/react/naj/libs/util/src/index.ts";
import { atom } from "/@fs/C:/Users/aintrona/Desktop/App/react/naj/node_modules/.vite/apps/naj/deps/jotai.js?v=0189a8d1";
import { StepsGraph } from "/@fs/C:/Users/aintrona/Desktop/App/react/naj/libs/engine/src/lib/StepsGraph.ts";
export async function findAsync(array, predicate) {
  for (const item of array) {
    if (await predicate(item)) {
      return item;
    }
  }
  return void 0;
}
export async function filterAsync(array, predicate) {
  const results = await Promise.all(array.map((item) => {
    return predicate(item);
  }));
  return array.filter((_, i) => results[i]);
}
export function getStepsCollectionAtoms(store, steps, handleNoStep) {
  async function getOrderedSteps(_steps = steps) {
    const array = Array.from(_steps);
    const graph = new StepsGraph(await filterAsync(array, (step) => store.get(step.isInFluxAtom)), store.get);
    return graph.getSortedSteps();
  }
  async function getProgress(orderedSteps, currentStep) {
    const totalSteps = await filterAsync(orderedSteps, (step) => store.get(step.countOnTotalProgressAtom));
    const totalCount = totalSteps.length;
    const currentIndex = orderedSteps.findIndex((s) => s === currentStep);
    const doneSteps = await filterAsync(orderedSteps.slice(0, currentIndex), (step) => store.get(step.countOnCurrentProgressAtom));
    const doneCount = doneSteps.length + 1;
    if (import.meta.env.DEV) {
      console.log(`Progress:
${doneSteps} / ${totalSteps}`);
    }
    return doneCount / totalCount * 100;
  }
  async function getInitialState() {
    const orderedSteps = await getOrderedSteps();
    let index = 0;
    let step = orderedSteps[index];
    while (step && !await store.get(step.canBeTheNextSkipIfDoneAtom)) {
      index += 1;
      step = orderedSteps[index];
    }
    if (step) step.skipIfDone = false;
    return {
      step,
      direction: 0,
      progress: await getProgress(orderedSteps, step)
    };
  }
  async function getNextStep(state, increment, handleNoStep2) {
    if (state.step == null) {
      return state;
    }
    async function calculateNextStep(steps2, currentStep, canBeTheNext, incrementWhen = "before") {
      let index = steps2.findIndex((s) => s === currentStep);
      if (index === -1) {
        console.warn(`STEPS COLLECTION STATE ERROR step ${currentStep} not found`);
        index = 0;
      }
      const stepToDo = await findAsync(steps2.slice(0, index), async (step3) => store.get(step3.isAvailableAtom) && store.get(step3.toDoAtom));
      if (stepToDo) {
        console.log(`Step "${stepToDo}" is seen because is not done.`);
        return stepToDo;
      }
      if (incrementWhen === "before") {
        index += increment;
      }
      let step2 = steps2[index];
      while (step2 && !await canBeTheNext(step2)) {
        index += increment;
        step2 = steps2[index];
      }
      return step2;
    }
    const orderedSteps = await getOrderedSteps();
    let step;
    let subflow = state.subflow;
    if (subflow) {
      const masterStep = subflow.masterStep;
      const index = orderedSteps.findIndex((s) => s === masterStep);
      const comunqueSarannoVistiDopo = orderedSteps.slice(index);
      step = await calculateNextStep(await getOrderedSteps(subflow.steps), state.step, async (step2) => !comunqueSarannoVistiDopo.includes(step2) && await store.get(step2.canBeTheNextAtom));
      const subFlowIsFinished = step == null;
      if (subFlowIsFinished) {
        step = await calculateNextStep(orderedSteps, masterStep, (step2) => store.get(step2.canBeTheNextSkipIfDoneAtom), "after");
        subflow = void 0;
      }
    } else {
      step = await calculateNextStep(orderedSteps, state.step, (step2) => store.get(step2.canBeTheNextSkipIfDoneAtom));
    }
    if (step == null) {
      setTimeout(() => handleNoStep2(increment), 0);
      return state;
    }
    if (step) step.skipIfDone = false;
    return {
      ...state,
      step,
      direction: increment,
      progress: await getProgress(orderedSteps, step),
      subflow
    };
  }
  async function getEditStep(state, data) {
    const orderedSteps = await getOrderedSteps();
    const step = await findAsync(orderedSteps, async (step2) => step2.provides(store.get).includes(data) && await store.get(step2.canBeEditedAtom));
    if (step == null) {
      throw Error(`No steps available for edit "${data}"`);
    }
    return startSubflow(state, new StepsGraph(orderedSteps, store.get).getDipendentiRicorsivo(step));
  }
  async function startSubflow(state, steps2) {
    if (state.step == null) {
      return state;
    }
    const orderedSteps = await getOrderedSteps();
    const currentStep = state.step;
    const orderedSubSteps = await getOrderedSteps(steps2);
    const step = orderedSubSteps[0];
    const lastIndex = orderedSteps.findIndex((s) => s === currentStep);
    const currentIndex = orderedSteps.findIndex((s) => s === step);
    const direction = currentIndex >= lastIndex ? 1 : -1;
    if (step) step.skipIfDone = false;
    return {
      ...state,
      step,
      direction,
      progress: await getProgress(orderedSteps, step),
      subflow: {
        steps: steps2,
        masterStep: state.step
      }
    };
  }
  function getAtom(getState) {
    return atom(async () => {
      const state = await getState();
      console.log("STEPS COLLECTION STATE", state);
      const handleError = (error) => ({
        ...state,
        error
      });
      return {
        error: state.error,
        currentStep: state.step,
        lastDirection: state.direction,
        progress: state.progress,
        nextStepAtom: (increment = 1) => getAtom(() => tryAsyncOrF(getNextStep(state, increment, handleNoStep), handleError)),
        editStepAtom: (data) => getAtom(() => tryAsyncOrF(getEditStep(state, data), handleError)),
        startSubflowAtom: (steps2) => getAtom(() => tryAsyncOrF(startSubflow(state, steps2), handleError)),
        clearErrorAtom: () => getAtom(async () => {
          const {
            error,
            ...stateWithoutError
          } = state;
          return stateWithoutError;
        })
      };
    });
  }
  return getAtom(getInitialState);
}

//# sourceMappingURL=data:application/json;base64,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O0FBQUEsWUFBRUc7QUFBQUEsWUFBTyxHQUFHTTtBQUFBQSxVQUFrQixJQUFJbEM7QUFDeEMsaUJBQU9rQztBQUFBQSxRQUNULENBQUM7QUFBQSxNQUNMO0FBQUEsSUFDRixDQUFDO0FBQUEsRUFDSDtBQUVBLFNBQU9ULFFBQVFoQyxlQUFlO0FBQ2hDIiwibmFtZXMiOlsidHJ5QXN5bmNPckYiLCJhdG9tIiwiU3RlcHNHcmFwaCIsImZpbmRBc3luYyIsImFycmF5IiwicHJlZGljYXRlIiwiaXRlbSIsInVuZGVmaW5lZCIsImZpbHRlckFzeW5jIiwicmVzdWx0cyIsIlByb21pc2UiLCJhbGwiLCJtYXAiLCJmaWx0ZXIiLCJfIiwiaSIsImdldFN0ZXBzQ29sbGVjdGlvbkF0b21zIiwic3RvcmUiLCJzdGVwcyIsImhhbmRsZU5vU3RlcCIsImdldE9yZGVyZWRTdGVwcyIsIl9zdGVwcyIsIkFycmF5IiwiZnJvbSIsImdyYXBoIiwic3RlcCIsImdldCIsImlzSW5GbHV4QXRvbSIsImdldFNvcnRlZFN0ZXBzIiwiZ2V0UHJvZ3Jlc3MiLCJvcmRlcmVkU3RlcHMiLCJjdXJyZW50U3RlcCIsInRvdGFsU3RlcHMiLCJjb3VudE9uVG90YWxQcm9ncmVzc0F0b20iLCJ0b3RhbENvdW50IiwibGVuZ3RoIiwiY3VycmVudEluZGV4IiwiZmluZEluZGV4IiwicyIsImRvbmVTdGVwcyIsInNsaWNlIiwiY291bnRPbkN1cnJlbnRQcm9ncmVzc0F0b20iLCJkb25lQ291bnQiLCJpbXBvcnQiLCJlbnYiLCJERVYiLCJjb25zb2xlIiwibG9nIiwiZ2V0SW5pdGlhbFN0YXRlIiwiaW5kZXgiLCJjYW5CZVRoZU5leHRTa2lwSWZEb25lQXRvbSIsInNraXBJZkRvbmUiLCJkaXJlY3Rpb24iLCJwcm9ncmVzcyIsImdldE5leHRTdGVwIiwic3RhdGUiLCJpbmNyZW1lbnQiLCJjYWxjdWxhdGVOZXh0U3RlcCIsImNhbkJlVGhlTmV4dCIsImluY3JlbWVudFdoZW4iLCJ3YXJuIiwic3RlcFRvRG8iLCJpc0F2YWlsYWJsZUF0b20iLCJ0b0RvQXRvbSIsInN1YmZsb3ciLCJtYXN0ZXJTdGVwIiwiY29tdW5xdWVTYXJhbm5vVmlzdGlEb3BvIiwiaW5jbHVkZXMiLCJjYW5CZVRoZU5leHRBdG9tIiwic3ViRmxvd0lzRmluaXNoZWQiLCJzZXRUaW1lb3V0IiwiZ2V0RWRpdFN0ZXAiLCJkYXRhIiwicHJvdmlkZXMiLCJjYW5CZUVkaXRlZEF0b20iLCJFcnJvciIsInN0YXJ0U3ViZmxvdyIsImdldERpcGVuZGVudGlSaWNvcnNpdm8iLCJvcmRlcmVkU3ViU3RlcHMiLCJsYXN0SW5kZXgiLCJnZXRBdG9tIiwiZ2V0U3RhdGUiLCJoYW5kbGVFcnJvciIsImVycm9yIiwibGFzdERpcmVjdGlvbiIsIm5leHRTdGVwQXRvbSIsImVkaXRTdGVwQXRvbSIsInN0YXJ0U3ViZmxvd0F0b20iLCJjbGVhckVycm9yQXRvbSIsInN0YXRlV2l0aG91dEVycm9yIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbImdldFN0ZXBzQ29sbGVjdGlvbkF0b21zLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHRyeUFzeW5jT3JGIH0gZnJvbSAnQG5hai13by91dGlsJztcclxuaW1wb3J0IHsgYXRvbSwgQXRvbSB9IGZyb20gJ2pvdGFpJztcclxuaW1wb3J0IHsgRGF0YUtleSwgU3RlcCB9IGZyb20gJy4vU3RlcCc7XHJcbmltcG9ydCB7IFN0ZXBzR3JhcGggfSBmcm9tICcuL1N0ZXBzR3JhcGgnO1xyXG5pbXBvcnQgeyB0eXBlIGNyZWF0ZVN0b3JlIH0gZnJvbSAnam90YWkvdmFuaWxsYSc7XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmluZEFzeW5jPFQ+KFxyXG4gIGFycmF5OiByZWFkb25seSBUW10sXHJcbiAgcHJlZGljYXRlOiAoaXRlbTogVCkgPT4gUHJvbWlzZTxib29sZWFuPlxyXG4pOiBQcm9taXNlPFQgfCB1bmRlZmluZWQ+IHtcclxuICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyYXkpIHtcclxuICAgIGlmIChhd2FpdCBwcmVkaWNhdGUoaXRlbSkpIHtcclxuICAgICAgcmV0dXJuIGl0ZW07XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmaWx0ZXJBc3luYzxUPihcclxuICBhcnJheTogcmVhZG9ubHkgVFtdLFxyXG4gIHByZWRpY2F0ZTogKGl0ZW06IFQpID0+IFByb21pc2U8Ym9vbGVhbj5cclxuKTogUHJvbWlzZTxUW10+IHtcclxuICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXHJcbiAgICBhcnJheS5tYXAoKGl0ZW0pID0+IHtcclxuICAgICAgcmV0dXJuIHByZWRpY2F0ZShpdGVtKTtcclxuICAgIH0pXHJcbiAgKTtcclxuICByZXR1cm4gYXJyYXkuZmlsdGVyKChfLCBpKSA9PiByZXN1bHRzW2ldKTtcclxufVxyXG5cclxudHlwZSBTdGVwc0NvbGxlY3Rpb24gPSB7XHJcbiAgY3VycmVudFN0ZXA6IFN0ZXAgfCB1bmRlZmluZWQ7XHJcbiAgbGFzdERpcmVjdGlvbjogRGlyZWN0aW9uO1xyXG4gIHByb2dyZXNzOiBudW1iZXI7XHJcbiAgZXJyb3I/OiBhbnk7XHJcbiAgY2xlYXJFcnJvckF0b206ICgpID0+IFN0ZXBzQ29sbGVjdGlvbkF0b21zO1xyXG4gIG5leHRTdGVwQXRvbTogKGluY3JlbWVudDogSW5jcmVtZW50KSA9PiBTdGVwc0NvbGxlY3Rpb25BdG9tcztcclxuICBlZGl0U3RlcEF0b206IChkYXRhOiBEYXRhS2V5KSA9PiBTdGVwc0NvbGxlY3Rpb25BdG9tcztcclxuICBzdGFydFN1YmZsb3dBdG9tOiAoc3RlcHM6IHJlYWRvbmx5IFN0ZXBbXSkgPT4gU3RlcHNDb2xsZWN0aW9uQXRvbXM7XHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBTdGVwc0NvbGxlY3Rpb25BdG9tcyA9IEF0b208UHJvbWlzZTxTdGVwc0NvbGxlY3Rpb24+PjtcclxuXHJcbnR5cGUgSW5jcmVtZW50ID0gLTEgfCAxO1xyXG50eXBlIERpcmVjdGlvbiA9IEluY3JlbWVudCB8IDA7XHJcblxyXG50eXBlIFN0YXRlID0ge1xyXG4gIHN0ZXA6IFN0ZXAgfCB1bmRlZmluZWQ7XHJcbiAgZGlyZWN0aW9uOiBEaXJlY3Rpb247XHJcbiAgcHJvZ3Jlc3M6IG51bWJlcjtcclxuICBlcnJvcj86IGFueTtcclxuICBzdWJmbG93Pzoge1xyXG4gICAgLyoqIFRoZSBzdGVwcyB0aGF0IGFyZSBpbiB0aGUgc3ViZmxvdy4gKi9cclxuICAgIHN0ZXBzOiBJdGVyYWJsZTxTdGVwPjtcclxuICAgIC8qKiBUaGUgc3RlcCB3aGVyZSB3ZSB3ZXJlIGJlZm9yZSB0aGUgc3ViZmxvdyBoYXMgc3RhcnRlZC4gKi9cclxuICAgIG1hc3RlclN0ZXA6IFN0ZXA7XHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTdGVwc0NvbGxlY3Rpb25BdG9tcyhcclxuICBzdG9yZTogUmV0dXJuVHlwZTx0eXBlb2YgY3JlYXRlU3RvcmU+LFxyXG4gIHN0ZXBzOiBJdGVyYWJsZTxTdGVwPixcclxuICBoYW5kbGVOb1N0ZXA6IChkaXJlY3Rpb246IG51bWJlcikgPT4gdm9pZFxyXG4pIHtcclxuICBhc3luYyBmdW5jdGlvbiBnZXRPcmRlcmVkU3RlcHMoX3N0ZXBzID0gc3RlcHMpOiBQcm9taXNlPHJlYWRvbmx5IFN0ZXBbXT4ge1xyXG4gICAgY29uc3QgYXJyYXkgPSBBcnJheS5mcm9tKF9zdGVwcyk7XHJcbiAgICBjb25zdCBncmFwaCA9IG5ldyBTdGVwc0dyYXBoKFxyXG4gICAgICBhd2FpdCBmaWx0ZXJBc3luYyhhcnJheSwgKHN0ZXApID0+IHN0b3JlLmdldChzdGVwLmlzSW5GbHV4QXRvbSkpLFxyXG4gICAgICBzdG9yZS5nZXRcclxuICAgICk7XHJcbiAgICByZXR1cm4gZ3JhcGguZ2V0U29ydGVkU3RlcHMoKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGZ1bmN0aW9uIGdldFByb2dyZXNzKFxyXG4gICAgb3JkZXJlZFN0ZXBzOiByZWFkb25seSBTdGVwW10sXHJcbiAgICBjdXJyZW50U3RlcDogU3RlcCB8IHVuZGVmaW5lZFxyXG4gICkge1xyXG4gICAgY29uc3QgdG90YWxTdGVwcyA9IGF3YWl0IGZpbHRlckFzeW5jKG9yZGVyZWRTdGVwcywgKHN0ZXApID0+XHJcbiAgICAgIHN0b3JlLmdldChzdGVwLmNvdW50T25Ub3RhbFByb2dyZXNzQXRvbSlcclxuICAgICk7XHJcbiAgICBjb25zdCB0b3RhbENvdW50ID0gdG90YWxTdGVwcy5sZW5ndGg7IC8vICsgLSBAIF5cclxuXHJcbiAgICBjb25zdCBjdXJyZW50SW5kZXggPSBvcmRlcmVkU3RlcHMuZmluZEluZGV4KChzKSA9PiBzID09PSBjdXJyZW50U3RlcCk7XHJcbiAgICBjb25zdCBkb25lU3RlcHMgPSBhd2FpdCBmaWx0ZXJBc3luYyhcclxuICAgICAgb3JkZXJlZFN0ZXBzLnNsaWNlKDAsIGN1cnJlbnRJbmRleCksXHJcbiAgICAgIChzdGVwKSA9PiBzdG9yZS5nZXQoc3RlcC5jb3VudE9uQ3VycmVudFByb2dyZXNzQXRvbSlcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgZG9uZUNvdW50ID0gZG9uZVN0ZXBzLmxlbmd0aCArIDE7IC8vIC0gQFxyXG5cclxuICAgIGlmIChpbXBvcnQubWV0YS5lbnYuREVWKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGBQcm9ncmVzczpcXG4ke2RvbmVTdGVwc30gLyAke3RvdGFsU3RlcHN9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIChkb25lQ291bnQgLyB0b3RhbENvdW50KSAqIDEwMDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgZmlyc3Qgc3RlcC5cclxuICAgKi9cclxuICBhc3luYyBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoKTogUHJvbWlzZTxTdGF0ZT4ge1xyXG4gICAgY29uc3Qgb3JkZXJlZFN0ZXBzID0gYXdhaXQgZ2V0T3JkZXJlZFN0ZXBzKCk7XHJcbiAgICBsZXQgaW5kZXggPSAwO1xyXG4gICAgbGV0IHN0ZXAgPSBvcmRlcmVkU3RlcHNbaW5kZXhdO1xyXG5cclxuICAgIHdoaWxlIChzdGVwICYmICEoYXdhaXQgc3RvcmUuZ2V0KHN0ZXAuY2FuQmVUaGVOZXh0U2tpcElmRG9uZUF0b20pKSkge1xyXG4gICAgICBpbmRleCArPSAxO1xyXG4gICAgICBzdGVwID0gb3JkZXJlZFN0ZXBzW2luZGV4XTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc3RlcCkgc3RlcC5za2lwSWZEb25lID0gZmFsc2U7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdGVwLFxyXG4gICAgICBkaXJlY3Rpb246IDAsXHJcbiAgICAgIHByb2dyZXNzOiBhd2FpdCBnZXRQcm9ncmVzcyhvcmRlcmVkU3RlcHMsIHN0ZXApLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbmV4dCBzdGF0ZSB3aXRoIHRoZSBuZXh0IHN0ZXAuXHJcbiAgICogQHBhcmFtIHN0YXRlIGN1cnJlbnQgc3RhdGVcclxuICAgKiBAcGFyYW0gaW5jcmVtZW50IG5leHQgb3IgcHJldmlvdXNcclxuICAgKiBAcGFyYW0gaGFuZGxlTm9TdGVwIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIHRoZXJlIGFyZSBubyBtb3JlIHN0ZXBzXHJcbiAgICovXHJcbiAgYXN5bmMgZnVuY3Rpb24gZ2V0TmV4dFN0ZXAoXHJcbiAgICBzdGF0ZTogU3RhdGUsXHJcbiAgICBpbmNyZW1lbnQ6IEluY3JlbWVudCxcclxuICAgIGhhbmRsZU5vU3RlcDogKGRpcmVjdGlvbjogbnVtYmVyKSA9PiB2b2lkXHJcbiAgKTogUHJvbWlzZTxTdGF0ZT4ge1xyXG4gICAgaWYgKHN0YXRlLnN0ZXAgPT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgZnVuY3Rpb24gY2FsY3VsYXRlTmV4dFN0ZXAoXHJcbiAgICAgIHN0ZXBzOiByZWFkb25seSBTdGVwW10sXHJcbiAgICAgIGN1cnJlbnRTdGVwOiBTdGVwLFxyXG4gICAgICBjYW5CZVRoZU5leHQ6IChzdGVwOiBTdGVwKSA9PiBQcm9taXNlPGJvb2xlYW4+LFxyXG4gICAgICBpbmNyZW1lbnRXaGVuOiAnYmVmb3JlJyB8ICdhZnRlcicgPSAnYmVmb3JlJ1xyXG4gICAgKSB7XHJcbiAgICAgIGxldCBpbmRleCA9IHN0ZXBzLmZpbmRJbmRleCgocykgPT4gcyA9PT0gY3VycmVudFN0ZXApO1xyXG4gICAgICAvLyBJZiB0aGUgYGN1cnJlbnRTdGVwYCBpcyBub3QgaW4gYHN0ZXBzYCwgc3RhcnQgZnJvbSAwLlxyXG4gICAgICBpZiAoaW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgICAgYFNURVBTIENPTExFQ1RJT04gU1RBVEUgRVJST1Igc3RlcCAke2N1cnJlbnRTdGVwfSBub3QgZm91bmRgXHJcbiAgICAgICAgKTtcclxuICAgICAgICBpbmRleCA9IDA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8qXHJcbiAgICAgICAqIENoZWNrIGlmIHRoZXJlIGlzIGEgc3RlcCB0aGF0IGlzIGF2YWlsYWJsZSBhbmQgdG8gZG8gYmVmb3JlIHRoZSBjdXJyZW50IHN0ZXAuXHJcbiAgICAgICAqIFRoZSB1c2VyIHNob3VsZCBzZWUgdGhpcyBzdGVwLlxyXG4gICAgICAgKi9cclxuICAgICAgY29uc3Qgc3RlcFRvRG8gPSBhd2FpdCBmaW5kQXN5bmMoXHJcbiAgICAgICAgc3RlcHMuc2xpY2UoMCwgaW5kZXgpLFxyXG4gICAgICAgIGFzeW5jIChzdGVwKSA9PlxyXG4gICAgICAgICAgc3RvcmUuZ2V0KHN0ZXAuaXNBdmFpbGFibGVBdG9tKSAmJiBzdG9yZS5nZXQoc3RlcC50b0RvQXRvbSlcclxuICAgICAgKTtcclxuICAgICAgaWYgKHN0ZXBUb0RvKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYFN0ZXAgXCIke3N0ZXBUb0RvfVwiIGlzIHNlZW4gYmVjYXVzZSBpcyBub3QgZG9uZS5gKTtcclxuICAgICAgICByZXR1cm4gc3RlcFRvRG87XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpbmNyZW1lbnRXaGVuID09PSAnYmVmb3JlJykge1xyXG4gICAgICAgIGluZGV4ICs9IGluY3JlbWVudDtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IHN0ZXAgPSBzdGVwc1tpbmRleF07XHJcbiAgICAgIHdoaWxlIChzdGVwICYmICEoYXdhaXQgY2FuQmVUaGVOZXh0KHN0ZXApKSkge1xyXG4gICAgICAgIGluZGV4ICs9IGluY3JlbWVudDtcclxuICAgICAgICBzdGVwID0gc3RlcHNbaW5kZXhdO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBzdGVwO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG9yZGVyZWRTdGVwcyA9IGF3YWl0IGdldE9yZGVyZWRTdGVwcygpO1xyXG4gICAgbGV0IHN0ZXA6IFN0ZXAgfCB1bmRlZmluZWQ7XHJcbiAgICBsZXQgc3ViZmxvdyA9IHN0YXRlLnN1YmZsb3c7XHJcbiAgICBpZiAoc3ViZmxvdykge1xyXG4gICAgICBjb25zdCBtYXN0ZXJTdGVwID0gc3ViZmxvdy5tYXN0ZXJTdGVwO1xyXG4gICAgICBjb25zdCBpbmRleCA9IG9yZGVyZWRTdGVwcy5maW5kSW5kZXgoKHMpID0+IHMgPT09IG1hc3RlclN0ZXApO1xyXG4gICAgICBjb25zdCBjb211bnF1ZVNhcmFubm9WaXN0aURvcG8gPSBvcmRlcmVkU3RlcHMuc2xpY2UoaW5kZXgpO1xyXG5cclxuICAgICAgc3RlcCA9IGF3YWl0IGNhbGN1bGF0ZU5leHRTdGVwKFxyXG4gICAgICAgIGF3YWl0IGdldE9yZGVyZWRTdGVwcyhzdWJmbG93LnN0ZXBzKSxcclxuICAgICAgICBzdGF0ZS5zdGVwLFxyXG4gICAgICAgIGFzeW5jIChzdGVwKSA9PlxyXG4gICAgICAgICAgIWNvbXVucXVlU2FyYW5ub1Zpc3RpRG9wby5pbmNsdWRlcyhzdGVwKSAmJlxyXG4gICAgICAgICAgKGF3YWl0IHN0b3JlLmdldChzdGVwLmNhbkJlVGhlTmV4dEF0b20pKVxyXG4gICAgICApO1xyXG5cclxuICAgICAgY29uc3Qgc3ViRmxvd0lzRmluaXNoZWQgPSBzdGVwID09IG51bGw7XHJcbiAgICAgIGlmIChzdWJGbG93SXNGaW5pc2hlZCkge1xyXG4gICAgICAgIHN0ZXAgPSBhd2FpdCBjYWxjdWxhdGVOZXh0U3RlcChcclxuICAgICAgICAgIG9yZGVyZWRTdGVwcyxcclxuICAgICAgICAgIG1hc3RlclN0ZXAsXHJcbiAgICAgICAgICAoc3RlcCkgPT4gc3RvcmUuZ2V0KHN0ZXAuY2FuQmVUaGVOZXh0U2tpcElmRG9uZUF0b20pLFxyXG4gICAgICAgICAgJ2FmdGVyJ1xyXG4gICAgICAgICk7XHJcbiAgICAgICAgc3ViZmxvdyA9IHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc3RlcCA9IGF3YWl0IGNhbGN1bGF0ZU5leHRTdGVwKG9yZGVyZWRTdGVwcywgc3RhdGUuc3RlcCwgKHN0ZXApID0+XHJcbiAgICAgICAgc3RvcmUuZ2V0KHN0ZXAuY2FuQmVUaGVOZXh0U2tpcElmRG9uZUF0b20pXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHN0ZXAgPT0gbnVsbCkge1xyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IGhhbmRsZU5vU3RlcChpbmNyZW1lbnQpLCAwKTtcclxuICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzdGVwKSBzdGVwLnNraXBJZkRvbmUgPSBmYWxzZTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIC4uLnN0YXRlLFxyXG4gICAgICBzdGVwLFxyXG4gICAgICBkaXJlY3Rpb246IGluY3JlbWVudCxcclxuICAgICAgcHJvZ3Jlc3M6IGF3YWl0IGdldFByb2dyZXNzKG9yZGVyZWRTdGVwcywgc3RlcCksXHJcbiAgICAgIHN1YmZsb3c6IHN1YmZsb3csXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBuZXh0IHN0YXRlLlxyXG4gICAqIEBwYXJhbSBzdGF0ZSBjdXJyZW50IHN0YXRlXHJcbiAgICogQHBhcmFtIGRhdGEgaXRlbSB0byBlZGl0XHJcbiAgICovXHJcbiAgYXN5bmMgZnVuY3Rpb24gZ2V0RWRpdFN0ZXAoc3RhdGU6IFN0YXRlLCBkYXRhOiBEYXRhS2V5KTogUHJvbWlzZTxTdGF0ZT4ge1xyXG4gICAgY29uc3Qgb3JkZXJlZFN0ZXBzID0gYXdhaXQgZ2V0T3JkZXJlZFN0ZXBzKCk7XHJcbiAgICBjb25zdCBzdGVwID0gYXdhaXQgZmluZEFzeW5jKFxyXG4gICAgICBvcmRlcmVkU3RlcHMsXHJcbiAgICAgIGFzeW5jIChzdGVwKSA9PlxyXG4gICAgICAgIHN0ZXAucHJvdmlkZXMoc3RvcmUuZ2V0KS5pbmNsdWRlcyhkYXRhKSAmJlxyXG4gICAgICAgIChhd2FpdCBzdG9yZS5nZXQoc3RlcC5jYW5CZUVkaXRlZEF0b20pKVxyXG4gICAgKTtcclxuICAgIGlmIChzdGVwID09IG51bGwpIHtcclxuICAgICAgdGhyb3cgRXJyb3IoYE5vIHN0ZXBzIGF2YWlsYWJsZSBmb3IgZWRpdCBcIiR7ZGF0YX1cImApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdGFydFN1YmZsb3coXHJcbiAgICAgIHN0YXRlLFxyXG4gICAgICBuZXcgU3RlcHNHcmFwaChvcmRlcmVkU3RlcHMsIHN0b3JlLmdldCkuZ2V0RGlwZW5kZW50aVJpY29yc2l2byhzdGVwKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbmV4dCBzdGF0ZS5cclxuICAgKiBAcGFyYW0gc3RhdGUgY3VycmVudCBzdGF0ZVxyXG4gICAqIEBwYXJhbSBzdGVwcyBzdGVwcyBpbiBzdWJmbG93XHJcbiAgICovXHJcbiAgYXN5bmMgZnVuY3Rpb24gc3RhcnRTdWJmbG93KFxyXG4gICAgc3RhdGU6IFN0YXRlLFxyXG4gICAgc3RlcHM6IEl0ZXJhYmxlPFN0ZXA+XHJcbiAgKTogUHJvbWlzZTxTdGF0ZT4ge1xyXG4gICAgaWYgKHN0YXRlLnN0ZXAgPT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgb3JkZXJlZFN0ZXBzID0gYXdhaXQgZ2V0T3JkZXJlZFN0ZXBzKCk7XHJcbiAgICBjb25zdCBjdXJyZW50U3RlcCA9IHN0YXRlLnN0ZXA7XHJcblxyXG4gICAgY29uc3Qgb3JkZXJlZFN1YlN0ZXBzID0gYXdhaXQgZ2V0T3JkZXJlZFN0ZXBzKHN0ZXBzKTtcclxuICAgIGNvbnN0IHN0ZXAgPSBvcmRlcmVkU3ViU3RlcHNbMF07XHJcblxyXG4gICAgY29uc3QgbGFzdEluZGV4ID0gb3JkZXJlZFN0ZXBzLmZpbmRJbmRleCgocykgPT4gcyA9PT0gY3VycmVudFN0ZXApO1xyXG4gICAgY29uc3QgY3VycmVudEluZGV4ID0gb3JkZXJlZFN0ZXBzLmZpbmRJbmRleCgocykgPT4gcyA9PT0gc3RlcCk7XHJcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBjdXJyZW50SW5kZXggPj0gbGFzdEluZGV4ID8gMSA6IC0xO1xyXG5cclxuICAgIGlmIChzdGVwKSBzdGVwLnNraXBJZkRvbmUgPSBmYWxzZTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAuLi5zdGF0ZSxcclxuICAgICAgc3RlcDogc3RlcCxcclxuICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24sXHJcbiAgICAgIHByb2dyZXNzOiBhd2FpdCBnZXRQcm9ncmVzcyhvcmRlcmVkU3RlcHMsIHN0ZXApLFxyXG4gICAgICBzdWJmbG93OiB7XHJcbiAgICAgICAgc3RlcHM6IHN0ZXBzLFxyXG4gICAgICAgIG1hc3RlclN0ZXA6IHN0YXRlLnN0ZXAsXHJcbiAgICAgIH0sXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0QXRvbShnZXRTdGF0ZTogKCkgPT4gUHJvbWlzZTxTdGF0ZT4pOiBTdGVwc0NvbGxlY3Rpb25BdG9tcyB7XHJcbiAgICByZXR1cm4gYXRvbShhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHN0YXRlID0gYXdhaXQgZ2V0U3RhdGUoKTtcclxuICAgICAgY29uc29sZS5sb2coJ1NURVBTIENPTExFQ1RJT04gU1RBVEUnLCBzdGF0ZSk7XHJcbiAgICAgIGNvbnN0IGhhbmRsZUVycm9yID0gKGVycm9yOiB1bmtub3duKSA9PiAoeyAuLi5zdGF0ZSwgZXJyb3IgfSk7XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGVycm9yOiBzdGF0ZS5lcnJvcixcclxuICAgICAgICBjdXJyZW50U3RlcDogc3RhdGUuc3RlcCxcclxuICAgICAgICBsYXN0RGlyZWN0aW9uOiBzdGF0ZS5kaXJlY3Rpb24sXHJcbiAgICAgICAgcHJvZ3Jlc3M6IHN0YXRlLnByb2dyZXNzLFxyXG4gICAgICAgIG5leHRTdGVwQXRvbTogKGluY3JlbWVudCA9IDEpID0+XHJcbiAgICAgICAgICBnZXRBdG9tKCgpID0+XHJcbiAgICAgICAgICAgIHRyeUFzeW5jT3JGKFxyXG4gICAgICAgICAgICAgIGdldE5leHRTdGVwKHN0YXRlLCBpbmNyZW1lbnQsIGhhbmRsZU5vU3RlcCksXHJcbiAgICAgICAgICAgICAgaGFuZGxlRXJyb3JcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICAgKSxcclxuICAgICAgICBlZGl0U3RlcEF0b206IChkYXRhKSA9PlxyXG4gICAgICAgICAgZ2V0QXRvbSgoKSA9PiB0cnlBc3luY09yRihnZXRFZGl0U3RlcChzdGF0ZSwgZGF0YSksIGhhbmRsZUVycm9yKSksXHJcbiAgICAgICAgc3RhcnRTdWJmbG93QXRvbTogKHN0ZXBzKSA9PlxyXG4gICAgICAgICAgZ2V0QXRvbSgoKSA9PiB0cnlBc3luY09yRihzdGFydFN1YmZsb3coc3RhdGUsIHN0ZXBzKSwgaGFuZGxlRXJyb3IpKSxcclxuICAgICAgICBjbGVhckVycm9yQXRvbTogKCkgPT5cclxuICAgICAgICAgIGdldEF0b20oYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7IGVycm9yLCAuLi5zdGF0ZVdpdGhvdXRFcnJvciB9ID0gc3RhdGU7XHJcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZVdpdGhvdXRFcnJvcjtcclxuICAgICAgICAgIH0pLFxyXG4gICAgICB9IHNhdGlzZmllcyBTdGVwc0NvbGxlY3Rpb247XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHJldHVybiBnZXRBdG9tKGdldEluaXRpYWxTdGF0ZSk7XHJcbn1cclxuIl0sImZpbGUiOiJDOi9Vc2Vycy9haW50cm9uYS9EZXNrdG9wL0FwcC9yZWFjdC9uYWovbGlicy9lbmdpbmUvc3JjL2xpYi9nZXRTdGVwc0NvbGxlY3Rpb25BdG9tcy50cyJ9