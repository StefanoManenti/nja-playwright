globalThis.jotaiAtomCache = globalThis.jotaiAtomCache || { cache: /* @__PURE__ */ new Map(), get(name, inst) {
  if (this.cache.has(name)) {
    return this.cache.get(name);
  }
  this.cache.set(name, inst);
  return inst;
} };
import {
  customerSegmentAtom,
  existingDomiciliation$,
  operativeModeEnabled$,
  Payment,
  paymentType$,
  Segment,
  workingOnBroadbandAtom,
  workingOnPanelStandaloneAtom
} from "/@fs/C:/Users/aintrona/Desktop/App/react/naj/libs/data-access/src/index.ts";
import { Step, StepPriority } from "/@fs/C:/Users/aintrona/Desktop/App/react/naj/libs/engine/src/index.ts";
import StepErrorBoundary from "/@fs/C:/Users/aintrona/Desktop/App/react/naj/libs/steps/src/lib/StepErrorBoundary.tsx";
import { StepDependencies } from "/@fs/C:/Users/aintrona/Desktop/App/react/naj/libs/steps/src/lib/StepDependencies.ts";
class IbanResidential extends Step {
  constructor() {
    super(...arguments);
    this.priority = new StepPriority(30);
    this.lazy = () => import("/@fs/C:/Users/aintrona/Desktop/App/react/naj/libs/steps/src/lib/payment/IbanResidentialStep.tsx?t=1754041213313");
    this.WrapperComponent = StepErrorBoundary;
  }
  toString() {
    return "iban";
  }
  async isInFlux(get) {
    return !get(workingOnPanelStandaloneAtom) && (get(workingOnBroadbandAtom) || get(operativeModeEnabled$)) && await get(customerSegmentAtom) === Segment.RESID;
  }
  async isAvailable(get) {
    return await get(paymentType$) === Payment.DOMICILIATION && !await get(existingDomiciliation$);
  }
  depends() {
    return [StepDependencies.NAME, StepDependencies.TAX_ID];
  }
  provides() {
    return [StepDependencies.IBAN];
  }
}
export const ibanResidential = new IbanResidential();

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQUEsRUFDRUE7QUFBQUEsRUFDQUM7QUFBQUEsRUFDQUM7QUFBQUEsRUFDQUM7QUFBQUEsRUFDQUM7QUFBQUEsRUFDQUM7QUFBQUEsRUFDQUM7QUFBQUEsRUFDQUM7QUFBQUEsT0FDSztBQUNQLFNBQVNDLE1BQU1DLG9CQUFvQjtBQUVuQyxPQUFPQyx1QkFBdUI7QUFDOUIsU0FBU0Msd0JBQXdCO0FBRWpDLE1BQU1DLHdCQUF3QkosS0FBSztBQUFBLEVBQW5DO0FBQUE7QUFDRUssb0JBQVcsSUFBSUosYUFBYSxFQUFFO0FBRTlCSyxnQkFBT0EsTUFBTSxPQUFPLHVCQUF1QjtBQUMzQ0MsNEJBQW1CTDtBQUFBQTtBQUFBQSxFQUVuQk0sV0FBVztBQUNULFdBQU87QUFBQSxFQUNUO0FBQUEsRUFFQSxNQUFnQkMsU0FBU0MsS0FBYTtBQUNwQyxXQUNFLENBQUNBLElBQUlYLDRCQUE0QixNQUNoQ1csSUFBSVosc0JBQXNCLEtBQUtZLElBQUloQixxQkFBcUIsTUFDeEQsTUFBTWdCLElBQUlsQixtQkFBbUIsTUFBT0ssUUFBUWM7QUFBQUEsRUFFakQ7QUFBQSxFQUVBLE1BQWdCQyxZQUFZRixLQUFhO0FBQ3ZDLFdBQ0csTUFBTUEsSUFBSWQsWUFBWSxNQUFPRCxRQUFRa0IsaUJBQ3RDLENBQUUsTUFBTUgsSUFBSWpCLHNCQUFzQjtBQUFBLEVBRXRDO0FBQUEsRUFFQXFCLFVBQVU7QUFDUixXQUFPLENBQUNYLGlCQUFpQlksTUFBTVosaUJBQWlCYSxNQUFNO0FBQUEsRUFDeEQ7QUFBQSxFQUVBQyxXQUFXO0FBQ1QsV0FBTyxDQUFDZCxpQkFBaUJlLElBQUk7QUFBQSxFQUMvQjtBQUNGO0FBRU8sYUFBTUMsa0JBQWtCLElBQUlmLGdCQUFnQiIsIm5hbWVzIjpbImN1c3RvbWVyU2VnbWVudEF0b20iLCJleGlzdGluZ0RvbWljaWxpYXRpb24kIiwib3BlcmF0aXZlTW9kZUVuYWJsZWQkIiwiUGF5bWVudCIsInBheW1lbnRUeXBlJCIsIlNlZ21lbnQiLCJ3b3JraW5nT25Ccm9hZGJhbmRBdG9tIiwid29ya2luZ09uUGFuZWxTdGFuZGFsb25lQXRvbSIsIlN0ZXAiLCJTdGVwUHJpb3JpdHkiLCJTdGVwRXJyb3JCb3VuZGFyeSIsIlN0ZXBEZXBlbmRlbmNpZXMiLCJJYmFuUmVzaWRlbnRpYWwiLCJwcmlvcml0eSIsImxhenkiLCJXcmFwcGVyQ29tcG9uZW50IiwidG9TdHJpbmciLCJpc0luRmx1eCIsImdldCIsIlJFU0lEIiwiaXNBdmFpbGFibGUiLCJET01JQ0lMSUFUSU9OIiwiZGVwZW5kcyIsIk5BTUUiLCJUQVhfSUQiLCJwcm92aWRlcyIsIklCQU4iLCJpYmFuUmVzaWRlbnRpYWwiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiaWJhbi1yZXNpZGVudGlhbC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICBjdXN0b21lclNlZ21lbnRBdG9tLFxyXG4gIGV4aXN0aW5nRG9taWNpbGlhdGlvbiQsXHJcbiAgb3BlcmF0aXZlTW9kZUVuYWJsZWQkLFxyXG4gIFBheW1lbnQsXHJcbiAgcGF5bWVudFR5cGUkLFxyXG4gIFNlZ21lbnQsXHJcbiAgd29ya2luZ09uQnJvYWRiYW5kQXRvbSxcclxuICB3b3JraW5nT25QYW5lbFN0YW5kYWxvbmVBdG9tLFxyXG59IGZyb20gJ0BuYWotd28vZGF0YS1hY2Nlc3MnO1xyXG5pbXBvcnQgeyBTdGVwLCBTdGVwUHJpb3JpdHkgfSBmcm9tICdAbmFqLXdvL2VuZ2luZSc7XHJcbmltcG9ydCB7IEdldHRlciB9IGZyb20gJ2pvdGFpL3ZhbmlsbGEvdHlwZVV0aWxzJztcclxuaW1wb3J0IFN0ZXBFcnJvckJvdW5kYXJ5IGZyb20gJy4uL1N0ZXBFcnJvckJvdW5kYXJ5JztcclxuaW1wb3J0IHsgU3RlcERlcGVuZGVuY2llcyB9IGZyb20gJy4uL1N0ZXBEZXBlbmRlbmNpZXMnO1xyXG5cclxuY2xhc3MgSWJhblJlc2lkZW50aWFsIGV4dGVuZHMgU3RlcCB7XHJcbiAgcHJpb3JpdHkgPSBuZXcgU3RlcFByaW9yaXR5KDMwKTtcclxuXHJcbiAgbGF6eSA9ICgpID0+IGltcG9ydCgnLi9JYmFuUmVzaWRlbnRpYWxTdGVwJyk7XHJcbiAgV3JhcHBlckNvbXBvbmVudCA9IFN0ZXBFcnJvckJvdW5kYXJ5O1xyXG5cclxuICB0b1N0cmluZygpIHtcclxuICAgIHJldHVybiAnaWJhbic7XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgYXN5bmMgaXNJbkZsdXgoZ2V0OiBHZXR0ZXIpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICFnZXQod29ya2luZ09uUGFuZWxTdGFuZGFsb25lQXRvbSkgJiZcclxuICAgICAgKGdldCh3b3JraW5nT25Ccm9hZGJhbmRBdG9tKSB8fCBnZXQob3BlcmF0aXZlTW9kZUVuYWJsZWQkKSkgJiZcclxuICAgICAgKGF3YWl0IGdldChjdXN0b21lclNlZ21lbnRBdG9tKSkgPT09IFNlZ21lbnQuUkVTSURcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgYXN5bmMgaXNBdmFpbGFibGUoZ2V0OiBHZXR0ZXIpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIChhd2FpdCBnZXQocGF5bWVudFR5cGUkKSkgPT09IFBheW1lbnQuRE9NSUNJTElBVElPTiAmJlxyXG4gICAgICAhKGF3YWl0IGdldChleGlzdGluZ0RvbWljaWxpYXRpb24kKSlcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBkZXBlbmRzKCkge1xyXG4gICAgcmV0dXJuIFtTdGVwRGVwZW5kZW5jaWVzLk5BTUUsIFN0ZXBEZXBlbmRlbmNpZXMuVEFYX0lEXTtcclxuICB9XHJcblxyXG4gIHByb3ZpZGVzKCkge1xyXG4gICAgcmV0dXJuIFtTdGVwRGVwZW5kZW5jaWVzLklCQU5dO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGliYW5SZXNpZGVudGlhbCA9IG5ldyBJYmFuUmVzaWRlbnRpYWwoKTtcclxuIl0sImZpbGUiOiJDOi9Vc2Vycy9haW50cm9uYS9EZXNrdG9wL0FwcC9yZWFjdC9uYWovbGlicy9zdGVwcy9zcmMvbGliL3BheW1lbnQvaWJhbi1yZXNpZGVudGlhbC50c3gifQ==