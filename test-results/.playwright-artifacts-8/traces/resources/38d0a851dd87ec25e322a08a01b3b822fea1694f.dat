import.meta.env = {"BASE_URL": "/", "DEV": true, "MODE": "development", "PROD": false, "SSR": false};globalThis.jotaiAtomCache = globalThis.jotaiAtomCache || {
  cache: /* @__PURE__ */ new Map(),
  get(name, inst) {
    if (this.cache.has(name)) {
      return this.cache.get(name);
    }
    this.cache.set(name, inst);
    return inst;
  }
};
import { atom } from "/@fs/C:/Users/aintrona/Desktop/App/react/naj/node_modules/.vite/apps/naj/deps/jotai.js?v=0189a8d1";
import { extractTelephoneCountryCode, synchronized } from "/@fs/C:/Users/aintrona/Desktop/App/react/naj/libs/util/src/index.ts";
import { sendOtpSms$ } from "/@fs/C:/Users/aintrona/Desktop/App/react/naj/libs/data-access/src/lib/api/otp/send-otp-sms.ts";
import { checkOtpSms$ } from "/@fs/C:/Users/aintrona/Desktop/App/react/naj/libs/data-access/src/lib/api/otp/check-otp-sms.ts";
const MAX_COUNTER_OTP = 3;
const WAIT_FOR = import.meta.env.DEV ? 5 : 60;
export const atomWithPhone = ({
  email$,
  givenName$,
  familyName$,
  telephone$ = atom(),
  verified$ = atom(false)
}) => {
  const token$ = atom();
  token$.debugLabel = "token$";
  const otpTimerForSend$ = atom(0);
  otpTimerForSend$.debugLabel = "otpTimerForSend$";
  const otpCanResend$ = atom(MAX_COUNTER_OTP);
  otpCanResend$.debugLabel = "otpCanResend$";
  const telephoneWithPrefix$ = atom(async (get) => (await extractTelephoneCountryCode(await get(telephone$)))?.full);
  telephoneWithPrefix$.debugLabel = "telephoneWithPrefix$";
  function startCountdown(setWaitTime) {
    const now = Date.now();
    setWaitTime(WAIT_FOR);
    const interval = setInterval(() => {
      const seconds = Math.round(WAIT_FOR - (Date.now() - now) / 1e3);
      setWaitTime(seconds);
      if (seconds <= 0) {
        clearInterval(interval);
      }
    }, 1e3);
  }
  const setAction = synchronized(async (get, set, args) => {
    const {
      countryCode,
      telephone
    } = args;
    const oldTelephone = await get(telephoneWithPrefix$);
    const newTelephone = countryCode + (telephone || "");
    if (oldTelephone === newTelephone) {
      await set(telephone$, newTelephone);
      return {
        verified: await get(verified$)
      };
    }
    await set(telephone$, newTelephone);
    await set(verified$, false);
    return {
      verified: false
    };
  });
  const sendOtpAction = synchronized(async (get, set, args) => {
    const toReturn = {
      verified: false
    };
    const timer = get(otpTimerForSend$);
    if (timer > 0) {
      return toReturn;
    }
    const otpCanResend = get(otpCanResend$);
    if (otpCanResend <= 0) {
      return toReturn;
    }
    const sendOtpSms = await get(sendOtpSms$);
    const result = await sendOtpSms.mutateAsync({
      email: await get(email$),
      phone: await get(telephoneWithPrefix$),
      givenName: await get(givenName$),
      familyName: await get(familyName$)
    });
    set(token$, result.token);
    const newOtpCanResend = otpCanResend - 1;
    set(otpCanResend$, newOtpCanResend);
    if (newOtpCanResend > 0) {
      startCountdown((s) => set(otpTimerForSend$, s));
    }
    return toReturn;
  });
  const checkOtpAction = synchronized(async (get, set, args) => {
    const {
      otp
    } = args;
    const checkOtpSms = await get(checkOtpSms$);
    await checkOtpSms.mutateAsync({
      phone: await get(telephoneWithPrefix$),
      token: get(token$),
      otp
    });
    await set(verified$, true);
    set(token$, void 0);
    return {
      verified: true
    };
  });
  return atom(async (get) => {
    const telephone = await get(telephone$);
    const verified = await get(verified$);
    return {
      ...await extractTelephoneCountryCode(telephone) || {},
      verified,
      otpTimerForSend$,
      otpCanResend$
    };
  }, async (get, set, args) => {
    switch (args.action) {
      case "SET":
        return setAction(get, set, args);
      case "SEND_OTP":
        return sendOtpAction(get, set, args);
      case "CHECK_OTP":
        return checkOtpAction(get, set, args);
    }
  });
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLFNBRUVBLFlBS0s7QUFDUCxTQUNFQyw2QkFFQUMsb0JBQ0s7QUFDUCxTQUFTQyxtQkFBbUI7QUFDNUIsU0FBU0Msb0JBQW9CO0FBSzdCLE1BQU1DLGtCQUFrQjtBQUV4QixNQUFNQyxXQUFXQyxZQUFZQyxJQUFJQyxNQUFNLElBQUk7QUF5Q3BDLGFBQU1DLGdCQUFnQkEsQ0FBQztBQUFBLEVBQzVCQztBQUFBQSxFQUNBQztBQUFBQSxFQUNBQztBQUFBQSxFQUNBQyxhQUFhZCxLQUFLO0FBQUEsRUFDbEJlLFlBQVlmLEtBQUssS0FBSztBQWV4QixNQUFNO0FBQ0osUUFBTWdCLFNBQVNoQixLQUFhO0FBQUVnQixTQUFBQyxhQUFBO0FBQzlCLFFBQU1DLG1CQUFtQmxCLEtBQUssQ0FBQztBQUFFa0IsbUJBQUFELGFBQUE7QUFDakMsUUFBTUUsZ0JBQWdCbkIsS0FBS0ssZUFBZTtBQUUxQ2MsZ0JBQUFGLGFBQUE7QUFJQSxRQUFNRyx1QkFBdUJwQixLQUMzQixPQUFPcUIsU0FDSixNQUFNcEIsNEJBQTRCLE1BQU1vQixJQUFJUCxVQUFVLENBQUMsSUFBSVEsSUFDaEU7QUFFQUYsdUJBQUFILGFBQUE7QUFJQSxXQUFTTSxlQUFlQyxhQUFrQztBQUN4RCxVQUFNQyxNQUFNQyxLQUFLRCxJQUFJO0FBQ3JCRCxnQkFBWWxCLFFBQVE7QUFDcEIsVUFBTXFCLFdBQVdDLFlBQVksTUFBTTtBQUNqQyxZQUFNQyxVQUFVQyxLQUFLQyxNQUFNekIsWUFBWW9CLEtBQUtELElBQUksSUFBSUEsT0FBTyxHQUFJO0FBQy9ERCxrQkFBWUssT0FBTztBQUNuQixVQUFJQSxXQUFXLEdBQUc7QUFDaEJHLHNCQUFjTCxRQUFRO0FBQUEsTUFDeEI7QUFBQSxJQUNGLEdBQUcsR0FBSTtBQUFBLEVBQ1Q7QUFLQSxRQUFNTSxZQUFZL0IsYUFDaEIsT0FBT21CLEtBQWFhLEtBQWFDLFNBQW9CO0FBQ25ELFVBQU07QUFBQSxNQUFFQztBQUFBQSxNQUFhQztBQUFBQSxJQUFVLElBQUlGO0FBQ25DLFVBQU1HLGVBQWUsTUFBTWpCLElBQUlELG9CQUFvQjtBQUNuRCxVQUFNbUIsZUFBZUgsZUFBZUMsYUFBYTtBQUNqRCxRQUFJQyxpQkFBaUJDLGNBQWM7QUFDakMsWUFBTUwsSUFBSXBCLFlBQVl5QixZQUFZO0FBQ2xDLGFBQU87QUFBQSxRQUFFQyxVQUFVLE1BQU1uQixJQUFJTixTQUFTO0FBQUEsTUFBRTtBQUFBLElBQzFDO0FBQ0EsVUFBTW1CLElBQUlwQixZQUFZeUIsWUFBWTtBQUNsQyxVQUFNTCxJQUFJbkIsV0FBVyxLQUFLO0FBQzFCLFdBQU87QUFBQSxNQUFFeUIsVUFBVTtBQUFBLElBQU07QUFBQSxFQUMzQixDQUNGO0FBVUEsUUFBTUMsZ0JBQWdCdkMsYUFDcEIsT0FBT21CLEtBQWFhLEtBQWFDLFNBQXdCO0FBQ3ZELFVBQU1PLFdBQVc7QUFBQSxNQUFFRixVQUFVO0FBQUEsSUFBTTtBQUNuQyxVQUFNRyxRQUFRdEIsSUFBSUgsZ0JBQWdCO0FBQ2xDLFFBQUl5QixRQUFRLEdBQUc7QUFDYixhQUFPRDtBQUFBQSxJQUNUO0FBQ0EsVUFBTUUsZUFBZXZCLElBQUlGLGFBQWE7QUFDdEMsUUFBSXlCLGdCQUFnQixHQUFHO0FBQ3JCLGFBQU9GO0FBQUFBLElBQ1Q7QUFDQSxVQUFNRyxhQUFhLE1BQU14QixJQUFJbEIsV0FBVztBQUN4QyxVQUFNMkMsU0FBUyxNQUFNRCxXQUFXRSxZQUFZO0FBQUEsTUFDMUNDLE9BQVEsTUFBTTNCLElBQUlWLE1BQU07QUFBQSxNQUN4QnNDLE9BQVEsTUFBTTVCLElBQUlELG9CQUFvQjtBQUFBLE1BQ3RDOEIsV0FBWSxNQUFNN0IsSUFBSVQsVUFBVTtBQUFBLE1BQ2hDdUMsWUFBYSxNQUFNOUIsSUFBSVIsV0FBVztBQUFBLElBQ3BDLENBQUM7QUFDRHFCLFFBQUlsQixRQUFROEIsT0FBT00sS0FBSztBQUN4QixVQUFNQyxrQkFBa0JULGVBQWU7QUFDdkNWLFFBQUlmLGVBQWVrQyxlQUFlO0FBQ2xDLFFBQUlBLGtCQUFrQixHQUFHO0FBQ3ZCOUIscUJBQWdCK0IsT0FBTXBCLElBQUloQixrQkFBa0JvQyxDQUFDLENBQUM7QUFBQSxJQUNoRDtBQUNBLFdBQU9aO0FBQUFBLEVBQ1QsQ0FDRjtBQUtBLFFBQU1hLGlCQUFpQnJELGFBQ3JCLE9BQU9tQixLQUFhYSxLQUFhQyxTQUF5QjtBQUN4RCxVQUFNO0FBQUEsTUFBRXFCO0FBQUFBLElBQUksSUFBSXJCO0FBQ2hCLFVBQU1zQixjQUFjLE1BQU1wQyxJQUFJakIsWUFBWTtBQUMxQyxVQUFNcUQsWUFBWVYsWUFBWTtBQUFBLE1BQzVCRSxPQUFRLE1BQU01QixJQUFJRCxvQkFBb0I7QUFBQSxNQUN0Q2dDLE9BQU8vQixJQUFJTCxNQUFNO0FBQUEsTUFDakJ3QztBQUFBQSxJQUNGLENBQUM7QUFDRCxVQUFNdEIsSUFBSW5CLFdBQVcsSUFBSTtBQUN6Qm1CLFFBQUlsQixRQUFRMEMsTUFBUztBQUNyQixXQUFPO0FBQUEsTUFBRWxCLFVBQVU7QUFBQSxJQUFLO0FBQUEsRUFDMUIsQ0FDRjtBQUVBLFNBQU94QyxLQUtMLE9BQU9xQixRQUFRO0FBQ2IsVUFBTWdCLFlBQVksTUFBTWhCLElBQUlQLFVBQVU7QUFFdEMsVUFBTTBCLFdBQVcsTUFBTW5CLElBQUlOLFNBQVM7QUFDcEMsV0FBTztBQUFBLE1BQ0wsR0FBSyxNQUFNZCw0QkFBNEJvQyxTQUFTLEtBQU0sQ0FBQztBQUFBLE1BQ3ZERztBQUFBQSxNQUNBdEI7QUFBQUEsTUFDQUM7QUFBQUEsSUFDRjtBQUFBLEVBQ0YsR0FDQSxPQUFPRSxLQUFLYSxLQUFLQyxTQUFTO0FBQ3hCLFlBQVFBLEtBQUt3QixRQUFNO0FBQUEsTUFDakIsS0FBSztBQUNILGVBQU8xQixVQUFVWixLQUFLYSxLQUFLQyxJQUFJO0FBQUEsTUFDakMsS0FBSztBQUNILGVBQU9NLGNBQWNwQixLQUFLYSxLQUFLQyxJQUFJO0FBQUEsTUFDckMsS0FBSztBQUNILGVBQU9vQixlQUFlbEMsS0FBS2EsS0FBS0MsSUFBSTtBQUFBLElBQ3hDO0FBQUEsRUFDRixDQUNGO0FBQ0YiLCJuYW1lcyI6WyJhdG9tIiwiZXh0cmFjdFRlbGVwaG9uZUNvdW50cnlDb2RlIiwic3luY2hyb25pemVkIiwic2VuZE90cFNtcyQiLCJjaGVja090cFNtcyQiLCJNQVhfQ09VTlRFUl9PVFAiLCJXQUlUX0ZPUiIsImltcG9ydCIsImVudiIsIkRFViIsImF0b21XaXRoUGhvbmUiLCJlbWFpbCQiLCJnaXZlbk5hbWUkIiwiZmFtaWx5TmFtZSQiLCJ0ZWxlcGhvbmUkIiwidmVyaWZpZWQkIiwidG9rZW4kIiwiZGVidWdMYWJlbCIsIm90cFRpbWVyRm9yU2VuZCQiLCJvdHBDYW5SZXNlbmQkIiwidGVsZXBob25lV2l0aFByZWZpeCQiLCJnZXQiLCJmdWxsIiwic3RhcnRDb3VudGRvd24iLCJzZXRXYWl0VGltZSIsIm5vdyIsIkRhdGUiLCJpbnRlcnZhbCIsInNldEludGVydmFsIiwic2Vjb25kcyIsIk1hdGgiLCJyb3VuZCIsImNsZWFySW50ZXJ2YWwiLCJzZXRBY3Rpb24iLCJzZXQiLCJhcmdzIiwiY291bnRyeUNvZGUiLCJ0ZWxlcGhvbmUiLCJvbGRUZWxlcGhvbmUiLCJuZXdUZWxlcGhvbmUiLCJ2ZXJpZmllZCIsInNlbmRPdHBBY3Rpb24iLCJ0b1JldHVybiIsInRpbWVyIiwib3RwQ2FuUmVzZW5kIiwic2VuZE90cFNtcyIsInJlc3VsdCIsIm11dGF0ZUFzeW5jIiwiZW1haWwiLCJwaG9uZSIsImdpdmVuTmFtZSIsImZhbWlseU5hbWUiLCJ0b2tlbiIsIm5ld090cENhblJlc2VuZCIsInMiLCJjaGVja090cEFjdGlvbiIsIm90cCIsImNoZWNrT3RwU21zIiwidW5kZWZpbmVkIiwiYWN0aW9uIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbInBob25lLWF0b21zLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgQXRvbSxcclxuICBhdG9tLFxyXG4gIEdldHRlcixcclxuICBTZXRTdGF0ZUFjdGlvbixcclxuICBTZXR0ZXIsXHJcbiAgV3JpdGFibGVBdG9tLFxyXG59IGZyb20gJ2pvdGFpJztcclxuaW1wb3J0IHtcclxuICBleHRyYWN0VGVsZXBob25lQ291bnRyeUNvZGUsXHJcbiAgdHlwZSBQaG9uZUV4dHJhY3RlZCxcclxuICBzeW5jaHJvbml6ZWQsXHJcbn0gZnJvbSAnQG5hai13by91dGlsJztcclxuaW1wb3J0IHsgc2VuZE90cFNtcyQgfSBmcm9tICcuLi8uLi9hcGkvb3RwL3NlbmQtb3RwLXNtcyc7XHJcbmltcG9ydCB7IGNoZWNrT3RwU21zJCB9IGZyb20gJy4uLy4uL2FwaS9vdHAvY2hlY2stb3RwLXNtcyc7XHJcblxyXG5leHBvcnQgdHlwZSBQaG9uZUF0b20gPSBSZXR1cm5UeXBlPHR5cGVvZiBhdG9tV2l0aFBob25lPjtcclxuXHJcbi8qKiBtYXhpbXVtIG51bWJlciBvZiByZXF1ZXN0cyBmb3Igc2VuZGluZyB0aGUgT1RQICovXHJcbmNvbnN0IE1BWF9DT1VOVEVSX09UUCA9IDM7XHJcbi8qKiBzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIHlvdSBjYW4gcmVxdWVzdCB0aGUgT1RQIGFnYWluICovXHJcbmNvbnN0IFdBSVRfRk9SID0gaW1wb3J0Lm1ldGEuZW52LkRFViA/IDUgOiA2MDtcclxuXHJcbi8qKlxyXG4gKiBUaGUgc3RhdGUgb2YgdGhlIHBob25lXHJcbiAqL1xyXG50eXBlIFBob25lQXRvbVZhbHVlID0gUGFydGlhbDxQaG9uZUV4dHJhY3RlZD4gJiB7XHJcbiAgLyoqIHRoZSBwaG9uZSBpcyBhbHJlYWR5IHZhbGlkYXRlZCB3aXRoIGFuIE9UUCAqL1xyXG4gIHZlcmlmaWVkOiBib29sZWFuO1xyXG4gIC8qKiBzdWJzY3JpYmUgdG8gdGhpcyBhdG9tIHRvIGdldCB0aGUgc2Vjb25kcyB0byB3YWl0IGJlZm9yZSByZXNlbmRpbmcgdGhlIE9UUCAqL1xyXG4gIG90cFRpbWVyRm9yU2VuZCQ6IEF0b208bnVtYmVyPjtcclxuICAvKiogc3Vic2NyaWJlIHRvIHRoaXMgYXRvbSB0byBnZXQgdGhlIG51bWJlciBvZiByZXRyaWVzIGF2YWlsYWJsZSBmb3IgcmVzZW5kaW5nIHRoZSBPVFAgdmlhIFNNUyAqL1xyXG4gIG90cENhblJlc2VuZCQ6IEF0b208bnVtYmVyPjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIHRlbGVwaG9uZVxyXG4gKi9cclxudHlwZSBTZXRBY3Rpb24gPSB7XHJcbiAgYWN0aW9uOiAnU0VUJztcclxuICBjb3VudHJ5Q29kZTogc3RyaW5nO1xyXG4gIHRlbGVwaG9uZT86IHN0cmluZztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZW5kIHRoZSBPVFAgdG8gdmFsaWRhdGUgdGhlIHRlbGVwaG9uZVxyXG4gKi9cclxudHlwZSBTZW5kT3RwQWN0aW9uID0ge1xyXG4gIGFjdGlvbjogJ1NFTkRfT1RQJztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayB0aGUgT1RQIHRvIHZhbGlkYXRlIHRoZSB0ZWxlcGhvbmVcclxuICovXHJcbnR5cGUgQ2hlY2tPdHBBY3Rpb24gPSB7XHJcbiAgYWN0aW9uOiAnQ0hFQ0tfT1RQJztcclxuICBvdHA6IHN0cmluZztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgYW4gYXRvbSB0aGF0IHdyYXBzIHRlbGVwaG9uZSQgYW5kIGFkZCBmdW5jdGlvbnMgdG8gc2VuZCBhbmQgY2hlY2sgT1RQIHZpYSBTTVMuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgYXRvbVdpdGhQaG9uZSA9ICh7XHJcbiAgZW1haWwkLFxyXG4gIGdpdmVuTmFtZSQsXHJcbiAgZmFtaWx5TmFtZSQsXHJcbiAgdGVsZXBob25lJCA9IGF0b20oKSBhcyBhbnksXHJcbiAgdmVyaWZpZWQkID0gYXRvbShmYWxzZSkgYXMgYW55LFxyXG59OiB7XHJcbiAgZW1haWwkOiBBdG9tPFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB8IHN0cmluZyB8IHVuZGVmaW5lZD47XHJcbiAgZ2l2ZW5OYW1lJDogQXRvbTxQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4gfCBzdHJpbmcgfCB1bmRlZmluZWQ+O1xyXG4gIGZhbWlseU5hbWUkOiBBdG9tPFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB8IHN0cmluZyB8IHVuZGVmaW5lZD47XHJcbiAgdGVsZXBob25lJD86IFdyaXRhYmxlQXRvbTxcclxuICAgIFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB8IHN0cmluZyB8IHVuZGVmaW5lZCxcclxuICAgIFtTZXRTdGF0ZUFjdGlvbjxzdHJpbmcgfCB1bmRlZmluZWQ+XSxcclxuICAgIFByb21pc2U8dm9pZD4gfCB2b2lkXHJcbiAgPjtcclxuICB2ZXJpZmllZCQ/OiBXcml0YWJsZUF0b208XHJcbiAgICBQcm9taXNlPGJvb2xlYW4+LFxyXG4gICAgW1NldFN0YXRlQWN0aW9uPGJvb2xlYW4+XSxcclxuICAgIFByb21pc2U8dm9pZD5cclxuICA+O1xyXG59KSA9PiB7XHJcbiAgY29uc3QgdG9rZW4kID0gYXRvbTxzdHJpbmc+KCk7XHJcbiAgY29uc3Qgb3RwVGltZXJGb3JTZW5kJCA9IGF0b20oMCk7XHJcbiAgY29uc3Qgb3RwQ2FuUmVzZW5kJCA9IGF0b20oTUFYX0NPVU5URVJfT1RQKTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIHN0cmluZyB3aXRoIHRlbGVwaG9uZSBhbmQgcHJlZml4LFxyXG4gICAqIHVzZSB0aGlzIGluc3RlYWQgb2YgdGVsZXBob25lJCBiZWNhdXNlIGl0IG1heSBub3QgY29udGFpbiB0aGUgcHJlZml4LlxyXG4gICAqL1xyXG4gIGNvbnN0IHRlbGVwaG9uZVdpdGhQcmVmaXgkID0gYXRvbShcclxuICAgIGFzeW5jIChnZXQpID0+XHJcbiAgICAgIChhd2FpdCBleHRyYWN0VGVsZXBob25lQ291bnRyeUNvZGUoYXdhaXQgZ2V0KHRlbGVwaG9uZSQpKSk/LmZ1bGxcclxuICApO1xyXG5cclxuICAvKipcclxuICAgKiBTdGFydCBhIGNvdW50ZG93blxyXG4gICAqIEBwYXJhbSBzZXRXYWl0VGltZSBjYWxsYmFjayBpbnZva2VkIGV2ZXJ5IHNlY29uZFxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHN0YXJ0Q291bnRkb3duKHNldFdhaXRUaW1lOiAoczogbnVtYmVyKSA9PiB2b2lkKSB7XHJcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG4gICAgc2V0V2FpdFRpbWUoV0FJVF9GT1IpO1xyXG4gICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHNlY29uZHMgPSBNYXRoLnJvdW5kKFdBSVRfRk9SIC0gKERhdGUubm93KCkgLSBub3cpIC8gMTAwMCk7XHJcbiAgICAgIHNldFdhaXRUaW1lKHNlY29uZHMpO1xyXG4gICAgICBpZiAoc2Vjb25kcyA8PSAwKSB7XHJcbiAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XHJcbiAgICAgIH1cclxuICAgIH0sIDEwMDApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHRoZSB0ZWxlcGhvbmUsIGlmIGNoYW5nZWQgc2V0IHZlcmlmaWVkIHRvIGZhbHNlLlxyXG4gICAqL1xyXG4gIGNvbnN0IHNldEFjdGlvbiA9IHN5bmNocm9uaXplZChcclxuICAgIGFzeW5jIChnZXQ6IEdldHRlciwgc2V0OiBTZXR0ZXIsIGFyZ3M6IFNldEFjdGlvbikgPT4ge1xyXG4gICAgICBjb25zdCB7IGNvdW50cnlDb2RlLCB0ZWxlcGhvbmUgfSA9IGFyZ3M7XHJcbiAgICAgIGNvbnN0IG9sZFRlbGVwaG9uZSA9IGF3YWl0IGdldCh0ZWxlcGhvbmVXaXRoUHJlZml4JCk7XHJcbiAgICAgIGNvbnN0IG5ld1RlbGVwaG9uZSA9IGNvdW50cnlDb2RlICsgKHRlbGVwaG9uZSB8fCAnJyk7XHJcbiAgICAgIGlmIChvbGRUZWxlcGhvbmUgPT09IG5ld1RlbGVwaG9uZSkge1xyXG4gICAgICAgIGF3YWl0IHNldCh0ZWxlcGhvbmUkLCBuZXdUZWxlcGhvbmUpO1xyXG4gICAgICAgIHJldHVybiB7IHZlcmlmaWVkOiBhd2FpdCBnZXQodmVyaWZpZWQkKSB9O1xyXG4gICAgICB9XHJcbiAgICAgIGF3YWl0IHNldCh0ZWxlcGhvbmUkLCBuZXdUZWxlcGhvbmUpO1xyXG4gICAgICBhd2FpdCBzZXQodmVyaWZpZWQkLCBmYWxzZSk7XHJcbiAgICAgIHJldHVybiB7IHZlcmlmaWVkOiBmYWxzZSB9O1xyXG4gICAgfVxyXG4gICk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlbmQgT1RQIGNvZGUgdG8gdGhlIHRlbGVwaG9uZSBudW1iZXIuXHJcbiAgICogUHJlY29uZGl0aW9uczpcclxuICAgKiAtIGVtYWlsJCBjb250YWlucyBhIHZhbHVlLFxyXG4gICAqIC0gZ2l2ZW5OYW1lJCBjb250YWlucyBhIHZhbHVlLFxyXG4gICAqIC0gZmFtaWx5TmFtZSQgY29udGFpbnMgYSB2YWx1ZSxcclxuICAgKiAtIHRlbGVwaG9uZSQgY29udGFpbnMgYSB2YWx1ZS5cclxuICAgKi9cclxuICBjb25zdCBzZW5kT3RwQWN0aW9uID0gc3luY2hyb25pemVkKFxyXG4gICAgYXN5bmMgKGdldDogR2V0dGVyLCBzZXQ6IFNldHRlciwgYXJnczogU2VuZE90cEFjdGlvbikgPT4ge1xyXG4gICAgICBjb25zdCB0b1JldHVybiA9IHsgdmVyaWZpZWQ6IGZhbHNlIH07XHJcbiAgICAgIGNvbnN0IHRpbWVyID0gZ2V0KG90cFRpbWVyRm9yU2VuZCQpO1xyXG4gICAgICBpZiAodGltZXIgPiAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHRvUmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IG90cENhblJlc2VuZCA9IGdldChvdHBDYW5SZXNlbmQkKTtcclxuICAgICAgaWYgKG90cENhblJlc2VuZCA8PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHRvUmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHNlbmRPdHBTbXMgPSBhd2FpdCBnZXQoc2VuZE90cFNtcyQpO1xyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZW5kT3RwU21zLm11dGF0ZUFzeW5jKHtcclxuICAgICAgICBlbWFpbDogKGF3YWl0IGdldChlbWFpbCQpKSEsXHJcbiAgICAgICAgcGhvbmU6IChhd2FpdCBnZXQodGVsZXBob25lV2l0aFByZWZpeCQpKSEsXHJcbiAgICAgICAgZ2l2ZW5OYW1lOiAoYXdhaXQgZ2V0KGdpdmVuTmFtZSQpKSEsXHJcbiAgICAgICAgZmFtaWx5TmFtZTogKGF3YWl0IGdldChmYW1pbHlOYW1lJCkpISxcclxuICAgICAgfSk7XHJcbiAgICAgIHNldCh0b2tlbiQsIHJlc3VsdC50b2tlbik7XHJcbiAgICAgIGNvbnN0IG5ld090cENhblJlc2VuZCA9IG90cENhblJlc2VuZCAtIDE7XHJcbiAgICAgIHNldChvdHBDYW5SZXNlbmQkLCBuZXdPdHBDYW5SZXNlbmQpO1xyXG4gICAgICBpZiAobmV3T3RwQ2FuUmVzZW5kID4gMCkge1xyXG4gICAgICAgIHN0YXJ0Q291bnRkb3duKChzKSA9PiBzZXQob3RwVGltZXJGb3JTZW5kJCwgcykpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0b1JldHVybjtcclxuICAgIH1cclxuICApO1xyXG5cclxuICAvKipcclxuICAgKiBDaGVjayB0aGUgT1RQIGNvZGUgd2l0aCB0aGUgb25lIHRoYXQgd2FzIHNlbnQgdG8gdGhlIHRlbGVwaG9uZS5cclxuICAgKi9cclxuICBjb25zdCBjaGVja090cEFjdGlvbiA9IHN5bmNocm9uaXplZChcclxuICAgIGFzeW5jIChnZXQ6IEdldHRlciwgc2V0OiBTZXR0ZXIsIGFyZ3M6IENoZWNrT3RwQWN0aW9uKSA9PiB7XHJcbiAgICAgIGNvbnN0IHsgb3RwIH0gPSBhcmdzO1xyXG4gICAgICBjb25zdCBjaGVja090cFNtcyA9IGF3YWl0IGdldChjaGVja090cFNtcyQpO1xyXG4gICAgICBhd2FpdCBjaGVja090cFNtcy5tdXRhdGVBc3luYyh7XHJcbiAgICAgICAgcGhvbmU6IChhd2FpdCBnZXQodGVsZXBob25lV2l0aFByZWZpeCQpKSEsXHJcbiAgICAgICAgdG9rZW46IGdldCh0b2tlbiQpISxcclxuICAgICAgICBvdHA6IG90cCxcclxuICAgICAgfSk7XHJcbiAgICAgIGF3YWl0IHNldCh2ZXJpZmllZCQsIHRydWUpO1xyXG4gICAgICBzZXQodG9rZW4kLCB1bmRlZmluZWQpO1xyXG4gICAgICByZXR1cm4geyB2ZXJpZmllZDogdHJ1ZSB9O1xyXG4gICAgfVxyXG4gICk7XHJcblxyXG4gIHJldHVybiBhdG9tPFxyXG4gICAgUHJvbWlzZTxQaG9uZUF0b21WYWx1ZT4sXHJcbiAgICBbU2V0QWN0aW9uIHwgU2VuZE90cEFjdGlvbiB8IENoZWNrT3RwQWN0aW9uXSxcclxuICAgIFByb21pc2U8eyB2ZXJpZmllZDogYm9vbGVhbiB9PlxyXG4gID4oXHJcbiAgICBhc3luYyAoZ2V0KSA9PiB7XHJcbiAgICAgIGNvbnN0IHRlbGVwaG9uZSA9IGF3YWl0IGdldCh0ZWxlcGhvbmUkKTtcclxuXHJcbiAgICAgIGNvbnN0IHZlcmlmaWVkID0gYXdhaXQgZ2V0KHZlcmlmaWVkJCk7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgLi4uKChhd2FpdCBleHRyYWN0VGVsZXBob25lQ291bnRyeUNvZGUodGVsZXBob25lKSkgfHwge30pLFxyXG4gICAgICAgIHZlcmlmaWVkOiB2ZXJpZmllZCxcclxuICAgICAgICBvdHBUaW1lckZvclNlbmQkLFxyXG4gICAgICAgIG90cENhblJlc2VuZCQsXHJcbiAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgYXN5bmMgKGdldCwgc2V0LCBhcmdzKSA9PiB7XHJcbiAgICAgIHN3aXRjaCAoYXJncy5hY3Rpb24pIHtcclxuICAgICAgICBjYXNlICdTRVQnOlxyXG4gICAgICAgICAgcmV0dXJuIHNldEFjdGlvbihnZXQsIHNldCwgYXJncyk7XHJcbiAgICAgICAgY2FzZSAnU0VORF9PVFAnOlxyXG4gICAgICAgICAgcmV0dXJuIHNlbmRPdHBBY3Rpb24oZ2V0LCBzZXQsIGFyZ3MpO1xyXG4gICAgICAgIGNhc2UgJ0NIRUNLX09UUCc6XHJcbiAgICAgICAgICByZXR1cm4gY2hlY2tPdHBBY3Rpb24oZ2V0LCBzZXQsIGFyZ3MpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgKTtcclxufTtcclxuIl0sImZpbGUiOiJDOi9Vc2Vycy9haW50cm9uYS9EZXNrdG9wL0FwcC9yZWFjdC9uYWovbGlicy9kYXRhLWFjY2Vzcy9zcmMvbGliL2F0b21zL2N1c3RvbWVyL3Bob25lLWF0b21zLnRzIn0=